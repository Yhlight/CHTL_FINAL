#include "CHTLJSGeneratorComplete.h"
#include <sstream>
#include <regex>
#include <algorithm>
#include <chrono>

namespace CHTLJS {

CHTLJSGeneratorComplete::CHTLJSGeneratorComplete(std::shared_ptr<CHTLJSContext> context)
    : CHTLJSGenerator(context), context_(context), generate_runtime_(true), 
      minify_output_(false), generate_source_map_(false), 
      generated_lines_(0), generated_code_size_(0) {
    if (!context_) {
        context_ = std::make_shared<CHTLJSContext>();
    }
    
    initializeCodeTemplates();
    initializeDefaultSettings();
}

CHTLJSGeneratorComplete::~CHTLJSGeneratorComplete() {
}

std::string CHTLJSGeneratorComplete::generate(std::shared_ptr<CHTLJSBaseNode> ast) {
    if (!ast) {
        return "";
    }
    
    validateNode(ast);
    
    std::stringstream ss;
    
    // 生成运行时系统
    if (generate_runtime_) {
        ss << generateRuntimeSetup() << "\n\n";
    }
    
    // 根据节点类型生成代码
    switch (ast->getType()) {
        case CHTLJSBaseNode::NodeType::SCRIPT_LOADER:
            ss << generateScriptLoaderSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::LISTEN:
            ss << generateListenSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::ANIMATE:
            ss << generateAnimateSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::ROUTER:
            ss << generateRouterSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::VIR:
            ss << generateVirSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::UTIL_THEN:
            ss << generateUtilThenSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::PRINTMYLOVE:
            ss << generatePrintMyloveSystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::INEVERAWAY:
            ss << generateINeverAwaySystem(ast);
            break;
        case CHTLJSBaseNode::NodeType::RESPONSIVE_GET:
            ss << generateResponsiveGetExpression(ast);
            break;
        case CHTLJSBaseNode::NodeType::RESPONSIVE_SET:
            ss << generateResponsiveSetExpression(ast);
            break;
        case CHTLJSBaseNode::NodeType::CHTL_SELECTOR:
            ss << generateCHTLSelectorExpression(ast);
            break;
        case CHTLJSBaseNode::NodeType::CHTL_RESPONSIVE:
            ss << generateCHTLResponsiveExpression(ast);
            break;
        case CHTLJSBaseNode::NodeType::IDENTIFIER:
            ss << generateIdentifier(ast);
            break;
        case CHTLJSBaseNode::NodeType::LITERAL:
            ss << generateLiteral(ast);
            break;
        case CHTLJSBaseNode::NodeType::BINARY_EXPRESSION:
            ss << generateBinaryExpression(ast);
            break;
        case CHTLJSBaseNode::NodeType::UNARY_EXPRESSION:
            ss << generateUnaryExpression(ast);
            break;
        case CHTLJSBaseNode::NodeType::ASSIGNMENT:
            ss << generateAssignment(ast);
            break;
        case CHTLJSBaseNode::NodeType::FUNCTION_CALL:
            ss << generateFunctionCall(ast);
            break;
        case CHTLJSBaseNode::NodeType::BLOCK_STATEMENT:
            ss << generateBlock(ast);
            break;
        case CHTLJSBaseNode::NodeType::VARIABLE_DECLARATION:
            ss << generateVariableDeclaration(ast);
            break;
        case CHTLJSBaseNode::NodeType::FUNCTION_DECLARATION:
            ss << generateFunctionDeclaration(ast);
            break;
        default:
            ss << "/* Unsupported node type */";
            break;
    }
    
    std::string result = ss.str();
    
    // 代码优化
    if (minify_output_) {
        result = optimizeGeneratedCode(result);
    }
    
    // 更新统计信息
    generated_lines_ = std::count(result.begin(), result.end(), '\n') + 1;
    generated_code_size_ = result.length();
    
    return result;
}

std::string CHTLJSGeneratorComplete::generateDocument(const std::vector<std::shared_ptr<CHTLJSBaseNode>>& statements) {
    std::stringstream ss;
    
    // 生成文档头部
    ss << "// Generated by CHTL JS Compiler\n";
    ss << "// CHTL JS is an independent programming language that compiles to JavaScript\n\n";
    
    // 生成运行时系统
    if (generate_runtime_) {
        ss << generateRuntimeSetup() << "\n\n";
    }
    
    // 生成语句
    for (const auto& statement : statements) {
        if (statement) {
            ss << generate(statement) << "\n";
        }
    }
    
    // 生成运行时清理
    if (generate_runtime_) {
        ss << "\n" << generateRuntimeCleanup();
    }
    
    std::string result = ss.str();
    
    // 代码优化
    if (minify_output_) {
        result = optimizeGeneratedCode(result);
    }
    
    return result;
}

std::string CHTLJSGeneratorComplete::generateScriptLoaderSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// ScriptLoader system\n";
    ss << "const chtljs_scriptLoader = {\n";
    ss << "    load: function(config) {\n";
    ss << "        return new Promise((resolve, reject) => {\n";
    
    // 处理参数
    auto attributes = node->getAttributes();
    for (const auto& attr : attributes) {
        if (attr.first == "src") {
            ss << "            const script = document.createElement('script');\n";
            ss << "            script.src = " << attr.second << ";\n";
            ss << "            script.onload = resolve;\n";
            ss << "            script.onerror = reject;\n";
            ss << "            document.head.appendChild(script);\n";
        } else if (attr.first == "type") {
            ss << "            // Script type: " << attr.second << "\n";
        }
    }
    
    ss << "        });\n";
    ss << "    }\n";
    ss << "};\n";
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateListenSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// Listen system\n";
    ss << "const chtljs_listen = {\n";
    ss << "    on: function(selector, event, handler) {\n";
    ss << "        const elements = chtljs_querySelector(selector);\n";
    ss << "        elements.forEach(el => {\n";
    ss << "            el.addEventListener(event, handler);\n";
    ss << "        });\n";
    ss << "    },\n";
    ss << "    off: function(selector, event, handler) {\n";
    ss << "        const elements = chtljs_querySelector(selector);\n";
    ss << "        elements.forEach(el => {\n";
    ss << "            el.removeEventListener(event, handler);\n";
    ss << "        });\n";
    ss << "    }\n";
    ss << "};\n";
    
    // 处理参数
    auto attributes = node->getAttributes();
    if (attributes.find("selector") != attributes.end() && 
        attributes.find("event") != attributes.end()) {
        ss << "chtljs_listen.on(" << attributes["selector"] << ", " 
           << attributes["event"] << ", function(e) {\n";
        
        // 处理子节点
        for (const auto& child : node->getChildren()) {
            ss << "    " << generate(child) << "\n";
        }
        
        ss << "});\n";
    }
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateAnimateSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// Animate system\n";
    ss << "const chtljs_animate = {\n";
    ss << "    to: function(selector, properties, duration, easing) {\n";
    ss << "        const elements = chtljs_querySelector(selector);\n";
    ss << "        return new Promise(resolve => {\n";
    ss << "            elements.forEach((el, index) => {\n";
    ss << "                el.style.transition = `all ${duration || 300}ms ${easing || 'ease'}`;\n";
    ss << "                Object.assign(el.style, properties);\n";
    ss << "                if (index === elements.length - 1) {\n";
    ss << "                    el.addEventListener('transitionend', resolve, { once: true });\n";
    ss << "                }\n";
    ss << "            });\n";
    ss << "        });\n";
    ss << "    }\n";
    ss << "};\n";
    
    // 处理参数
    auto attributes = node->getAttributes();
    if (attributes.find("selector") != attributes.end()) {
        ss << "chtljs_animate.to(" << attributes["selector"];
        
        if (attributes.find("properties") != attributes.end()) {
            ss << ", " << attributes["properties"];
        }
        if (attributes.find("duration") != attributes.end()) {
            ss << ", " << attributes["duration"];
        }
        if (attributes.find("easing") != attributes.end()) {
            ss << ", " << attributes["easing"];
        }
        
        ss << ");\n";
    }
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateRouterSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// Router system\n";
    ss << "const chtljs_router = {\n";
    ss << "    routes: {},\n";
    ss << "    navigate: function(path) {\n";
    ss << "        window.history.pushState({}, '', path);\n";
    ss << "        this.handleRoute(path);\n";
    ss << "    },\n";
    ss << "    handleRoute: function(path) {\n";
    ss << "        const route = this.routes[path];\n";
    ss << "        if (route && typeof route === 'function') {\n";
    ss << "            route();\n";
    ss << "        }\n";
    ss << "    },\n";
    ss << "    addRoute: function(path, handler) {\n";
    ss << "        this.routes[path] = handler;\n";
    ss << "    }\n";
    ss << "};\n";
    
    // 监听路由变化
    ss << "window.addEventListener('popstate', () => {\n";
    ss << "    chtljs_router.handleRoute(window.location.pathname);\n";
    ss << "});\n";
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateVirSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// Vir (Virtual Object) system\n";
    ss << "const chtljs_vir = {\n";
    ss << "    objects: {},\n";
    ss << "    create: function(name, generator) {\n";
    ss << "        this.objects[name] = {\n";
    ss << "            generator: generator,\n";
    ss << "            instances: []\n";
    ss << "        };\n";
    ss << "    },\n";
    ss << "    get: function(name) {\n";
    ss << "        const obj = this.objects[name];\n";
    ss << "        if (obj && obj.generator) {\n";
    ss << "            const instance = obj.generator();\n";
    ss << "            obj.instances.push(instance);\n";
    ss << "            return instance;\n";
    ss << "        }\n";
    ss << "        return null;\n";
    ss << "    }\n";
    ss << "};\n";
    
    // 处理虚拟对象定义
    std::string name = node->getAttribute("name");
    if (!name.empty() && !node->getChildren().empty()) {
        ss << "chtljs_vir.create('" << name << "', function() {\n";
        ss << "    return " << generate(node->getChildren()[0]) << ";\n";
        ss << "});\n";
    }
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateUtilThenSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// util.then system\n";
    ss << "const chtljs_util = {\n";
    ss << "    then: function(condition, changeCallback, thenCallback) {\n";
    ss << "        if (condition) {\n";
    ss << "            if (changeCallback) changeCallback();\n";
    ss << "            return {\n";
    ss << "                then: function(callback) {\n";
    ss << "                    if (callback) callback();\n";
    ss << "                    return this;\n";
    ss << "                }\n";
    ss << "            };\n";
    ss << "        }\n";
    ss << "        return { then: function() { return this; } };\n";
    ss << "    }\n";
    ss << "};\n";
    
    // 处理util.then调用
    auto children = node->getChildren();
    if (children.size() >= 3) {
        ss << "chtljs_util.then(\n";
        ss << "    " << generate(children[0]) << ",\n";
        ss << "    function() { " << generate(children[1]) << " },\n";
        ss << "    function() { " << generate(children[2]) << " }\n";
        ss << ");\n";
    }
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generatePrintMyloveSystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// printMylove system (Image to ASCII)\n";
    ss << "const chtljs_printMylove = {\n";
    ss << "    convert: function(imageSrc, options) {\n";
    ss << "        return new Promise((resolve, reject) => {\n";
    ss << "            const img = new Image();\n";
    ss << "            img.onload = function() {\n";
    ss << "                const canvas = document.createElement('canvas');\n";
    ss << "                const ctx = canvas.getContext('2d');\n";
    ss << "                \n";
    ss << "                canvas.width = options.width || 80;\n";
    ss << "                canvas.height = options.height || 40;\n";
    ss << "                \n";
    ss << "                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n";
    ss << "                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n";
    ss << "                \n";
    ss << "                let ascii = '';\n";
    ss << "                const chars = ' .:-=+*#%@';\n";
    ss << "                \n";
    ss << "                for (let y = 0; y < canvas.height; y++) {\n";
    ss << "                    for (let x = 0; x < canvas.width; x++) {\n";
    ss << "                        const i = (y * canvas.width + x) * 4;\n";
    ss << "                        const r = imageData.data[i];\n";
    ss << "                        const g = imageData.data[i + 1];\n";
    ss << "                        const b = imageData.data[i + 2];\n";
    ss << "                        const gray = (r + g + b) / 3;\n";
    ss << "                        const charIndex = Math.floor((gray / 255) * (chars.length - 1));\n";
    ss << "                        ascii += chars[charIndex];\n";
    ss << "                    }\n";
    ss << "                    ascii += '\\n';\n";
    ss << "                }\n";
    ss << "                \n";
    ss << "                resolve(ascii);\n";
    ss << "            };\n";
    ss << "            img.onerror = reject;\n";
    ss << "            img.src = imageSrc;\n";
    ss << "        });\n";
    ss << "    }\n";
    ss << "};\n";
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateINeverAwaySystem(std::shared_ptr<CHTLJSBaseNode> node) {
    std::stringstream ss;
    
    ss << "// iNeverAway system (Function Overloading)\n";
    ss << "const chtljs_iNeverAway = {\n";
    ss << "    functions: {},\n";
    ss << "    overload: function(name, argCount, func) {\n";
    ss << "        if (!this.functions[name]) {\n";
    ss << "            this.functions[name] = {};\n";
    ss << "        }\n";
    ss << "        this.functions[name][argCount] = func;\n";
    ss << "    },\n";
    ss << "    call: function(name, ...args) {\n";
    ss << "        const overloads = this.functions[name];\n";
    ss << "        if (overloads && overloads[args.length]) {\n";
    ss << "            return overloads[args.length](...args);\n";
    ss << "        }\n";
    ss << "        throw new Error(`No overload found for function ${name} with ${args.length} arguments`);\n";
    ss << "    }\n";
    ss << "};\n";
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateResponsiveGetExpression(std::shared_ptr<CHTLJSBaseNode> node) {
    std::string varName = node->getAttribute("variable");
    return "chtljs_reactive.get('" + varName + "')";
}

std::string CHTLJSGeneratorComplete::generateResponsiveSetExpression(std::shared_ptr<CHTLJSBaseNode> node) {
    std::string varName = node->getAttribute("variable");
    std::string value = "";
    
    if (!node->getChildren().empty()) {
        value = generate(node->getChildren()[0]);
    }
    
    return "chtljs_reactive.set('" + varName + "', " + value + ")";
}

std::string CHTLJSGeneratorComplete::generateCHTLSelectorExpression(std::shared_ptr<CHTLJSBaseNode> node) {
    std::string selector = node->getAttribute("selector");
    return "chtljs_querySelector('" + selector + "')";
}

std::string CHTLJSGeneratorComplete::generateCHTLResponsiveExpression(std::shared_ptr<CHTLJSBaseNode> node) {
    std::string varName = node->getAttribute("variable");
    return "chtljs_reactive.get('" + varName + "')";
}

std::string CHTLJSGeneratorComplete::generateRuntimeSetup() {
    std::stringstream ss;
    
    ss << "// CHTL JS Runtime Setup\n";
    ss << "(function() {\n";
    ss << "    'use strict';\n\n";
    
    // 响应式系统
    ss << generateReactiveVariableSystem() << "\n\n";
    
    // 选择器系统
    ss << generateCHTLSelectorFunction() << "\n\n";
    
    // 虚拟对象系统
    ss << generateVirtualObjectSystemCore() << "\n\n";
    
    // 事件系统
    ss << generateEventSystemCore() << "\n\n";
    
    // 动画系统
    ss << generateAnimationSystemCore() << "\n\n";
    
    // 路由系统
    ss << generateRouterSystemCore() << "\n\n";
    
    // 模块系统
    ss << generateModuleSystemCore() << "\n\n";
    
    // 工具系统
    ss << generateUtilSystemCore() << "\n\n";
    
    ss << "})();\n";
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateRuntimeCleanup() {
    std::stringstream ss;
    
    ss << "// CHTL JS Runtime Cleanup\n";
    ss << "(function() {\n";
    ss << "    // Cleanup reactive system\n";
    ss << "    if (window.chtljs_reactive && window.chtljs_reactive.cleanup) {\n";
    ss << "        window.chtljs_reactive.cleanup();\n";
    ss << "    }\n";
    ss << "    \n";
    ss << "    // Cleanup event listeners\n";
    ss << "    if (window.chtljs_eventCleanup) {\n";
    ss << "        window.chtljs_eventCleanup.forEach(cleanup => cleanup());\n";
    ss << "    }\n";
    ss << "})();\n";
    
    return ss.str();
}

std::string CHTLJSGeneratorComplete::generateReactiveVariableSystem() {
    return R"(
// Reactive Variable System
const chtljs_reactive = {
    variables: {},
    observers: {},
    
    get: function(name) {
        return this.variables[name];
    },
    
    set: function(name, value) {
        const oldValue = this.variables[name];
        this.variables[name] = value;
        
        if (this.observers[name] && oldValue !== value) {
            this.observers[name].forEach(callback => callback(value, oldValue));
        }
        
        return value;
    },
    
    observe: function(name, callback) {
        if (!this.observers[name]) {
            this.observers[name] = [];
        }
        this.observers[name].push(callback);
    },
    
    unobserve: function(name, callback) {
        if (this.observers[name]) {
            const index = this.observers[name].indexOf(callback);
            if (index > -1) {
                this.observers[name].splice(index, 1);
            }
        }
    },
    
    cleanup: function() {
        this.variables = {};
        this.observers = {};
    }
};

window.chtljs_reactive = chtljs_reactive;
)";
}

std::string CHTLJSGeneratorComplete::generateCHTLSelectorFunction() {
    return R"(
// CHTL Selector Function
function chtljs_querySelector(selector) {
    // Enhanced selector with CHTL-specific features
    if (typeof selector !== 'string') {
        return [];
    }
    
    // Handle special CHTL selectors
    if (selector.startsWith('{{') && selector.endsWith('}}')) {
        const innerSelector = selector.slice(2, -2);
        return Array.from(document.querySelectorAll(innerSelector));
    }
    
    return Array.from(document.querySelectorAll(selector));
}

window.chtljs_querySelector = chtljs_querySelector;
)";
}

std::string CHTLJSGeneratorComplete::generateVirtualObjectSystemCore() {
    return R"(
// Virtual Object System Core
const chtljs_virtualObjects = {
    registry: {},
    instances: {},
    
    register: function(name, factory) {
        this.registry[name] = factory;
    },
    
    create: function(name, ...args) {
        const factory = this.registry[name];
        if (!factory) {
            throw new Error(`Virtual object '${name}' not found`);
        }
        
        const instance = factory(...args);
        const id = this.generateId();
        this.instances[id] = instance;
        
        return { id, instance };
    },
    
    get: function(id) {
        return this.instances[id];
    },
    
    destroy: function(id) {
        delete this.instances[id];
    },
    
    generateId: function() {
        return Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
};

window.chtljs_virtualObjects = chtljs_virtualObjects;
)";
}

std::string CHTLJSGeneratorComplete::generateEventSystemCore() {
    return R"(
// Event System Core
const chtljs_events = {
    listeners: {},
    
    on: function(selector, event, handler, options = {}) {
        const elements = chtljs_querySelector(selector);
        const key = `${selector}:${event}`;
        
        if (!this.listeners[key]) {
            this.listeners[key] = [];
        }
        
        elements.forEach(element => {
            element.addEventListener(event, handler, options);
            this.listeners[key].push({ element, handler, options });
        });
    },
    
    off: function(selector, event, handler) {
        const key = `${selector}:${event}`;
        const listeners = this.listeners[key];
        
        if (listeners) {
            listeners.forEach(({ element, handler: h }) => {
                if (!handler || handler === h) {
                    element.removeEventListener(event, h);
                }
            });
            
            if (!handler) {
                delete this.listeners[key];
            }
        }
    },
    
    emit: function(selector, event, data) {
        const elements = chtljs_querySelector(selector);
        elements.forEach(element => {
            const customEvent = new CustomEvent(event, { detail: data });
            element.dispatchEvent(customEvent);
        });
    }
};

window.chtljs_events = chtljs_events;
)";
}

std::string CHTLJSGeneratorComplete::generateAnimationSystemCore() {
    return R"(
// Animation System Core
const chtljs_animations = {
    running: {},
    
    animate: function(selector, properties, options = {}) {
        const elements = chtljs_querySelector(selector);
        const duration = options.duration || 300;
        const easing = options.easing || 'ease';
        
        return Promise.all(elements.map(element => {
            return new Promise(resolve => {
                const animationId = this.generateId();
                this.running[animationId] = { element, resolve };
                
                element.style.transition = `all ${duration}ms ${easing}`;
                
                Object.assign(element.style, properties);
                
                element.addEventListener('transitionend', () => {
                    delete this.running[animationId];
                    resolve();
                }, { once: true });
                
                setTimeout(() => {
                    if (this.running[animationId]) {
                        delete this.running[animationId];
                        resolve();
                    }
                }, duration + 50);
            });
        }));
    },
    
    stop: function(animationId) {
        if (this.running[animationId]) {
            const { element, resolve } = this.running[animationId];
            element.style.transition = '';
            delete this.running[animationId];
            resolve();
        }
    },
    
    generateId: function() {
        return Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
};

window.chtljs_animations = chtljs_animations;
)";
}

std::string CHTLJSGeneratorComplete::generateRouterSystemCore() {
    return R"(
// Router System Core
const chtljs_router = {
    routes: {},
    currentRoute: null,
    
    add: function(path, handler) {
        this.routes[path] = handler;
    },
    
    navigate: function(path, state = {}) {
        window.history.pushState(state, '', path);
        this.handleRoute(path);
    },
    
    replace: function(path, state = {}) {
        window.history.replaceState(state, '', path);
        this.handleRoute(path);
    },
    
    handleRoute: function(path) {
        this.currentRoute = path;
        const handler = this.routes[path];
        
        if (handler) {
            if (typeof handler === 'function') {
                handler();
            } else if (typeof handler === 'object' && handler.component) {
                this.renderComponent(handler.component);
            }
        } else {
            this.handleNotFound(path);
        }
    },
    
    renderComponent: function(component) {
        // Basic component rendering
        const container = document.querySelector('#app') || document.body;
        if (typeof component === 'string') {
            container.innerHTML = component;
        } else if (typeof component === 'function') {
            container.innerHTML = component();
        }
    },
    
    handleNotFound: function(path) {
        console.warn(`Route not found: ${path}`);
        if (this.routes['*']) {
            this.routes['*']();
        }
    },
    
    init: function() {
        window.addEventListener('popstate', (e) => {
            this.handleRoute(window.location.pathname);
        });
        
        // Handle initial route
        this.handleRoute(window.location.pathname);
    }
};

window.chtljs_router = chtljs_router;
)";
}

std::string CHTLJSGeneratorComplete::generateModuleSystemCore() {
    return R"(
// Module System Core
const chtljs_modules = {
    loaded: {},
    loading: {},
    
    load: function(name, url) {
        if (this.loaded[name]) {
            return Promise.resolve(this.loaded[name]);
        }
        
        if (this.loading[name]) {
            return this.loading[name];
        }
        
        const loadPromise = new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = () => {
                this.loaded[name] = window[name] || true;
                delete this.loading[name];
                resolve(this.loaded[name]);
            };
            script.onerror = () => {
                delete this.loading[name];
                reject(new Error(`Failed to load module: ${name}`));
            };
            document.head.appendChild(script);
        });
        
        this.loading[name] = loadPromise;
        return loadPromise;
    },
    
    register: function(name, module) {
        this.loaded[name] = module;
    },
    
    get: function(name) {
        return this.loaded[name];
    },
    
    unload: function(name) {
        delete this.loaded[name];
        delete this.loading[name];
    }
};

window.chtljs_modules = chtljs_modules;
)";
}

std::string CHTLJSGeneratorComplete::generateUtilSystemCore() {
    return R"(
// Util System Core
const chtljs_util = {
    then: function(condition, changeCallback, thenCallback) {
        if (condition) {
            if (changeCallback && typeof changeCallback === 'function') {
                changeCallback();
            }
            
            return {
                then: function(callback) {
                    if (callback && typeof callback === 'function') {
                        callback();
                    }
                    return this;
                }
            };
        }
        
        return {
            then: function() {
                return this;
            }
        };
    },
    
    delay: function(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    },
    
    debounce: function(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    },
    
    throttle: function(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
};

window.chtljs_util = chtljs_util;
)";
}

std::string CHTLJSGeneratorComplete::optimizeGeneratedCode(const std::string& code) {
    std::string optimized = code;
    
    if (minify_output_) {
        optimized = minifyCode(optimized);
    }
    
    optimized = removeUnusedCode(optimized);
    
    return optimized;
}

std::string CHTLJSGeneratorComplete::minifyCode(const std::string& code) {
    std::string minified = code;
    
    // 移除注释
    minified = std::regex_replace(minified, std::regex(R"(//.*$)"), "", std::regex_constants::multiline);
    minified = std::regex_replace(minified, std::regex(R"(/\*.*?\*/)"), "", std::regex_constants::multiline | std::regex_constants::dotall);
    
    // 移除多余的空白
    minified = std::regex_replace(minified, std::regex(R"(\s+)"), " ");
    minified = std::regex_replace(minified, std::regex(R"(\s*([{}();,])\s*)"), "$1");
    
    // 移除行尾分号前的空格
    minified = std::regex_replace(minified, std::regex(R"(\s*;\s*)"), ";");
    
    return minified;
}

std::string CHTLJSGeneratorComplete::removeUnusedCode(const std::string& code) {
    // 简单的死代码移除
    std::string cleaned = code;
    
    // 移除空行
    cleaned = std::regex_replace(cleaned, std::regex(R"(\n\s*\n)"), "\n");
    
    return cleaned;
}

void CHTLJSGeneratorComplete::setGenerateRuntime(bool generate) {
    generate_runtime_ = generate;
}

bool CHTLJSGeneratorComplete::getGenerateRuntime() const {
    return generate_runtime_;
}

void CHTLJSGeneratorComplete::setMinifyOutput(bool minify) {
    minify_output_ = minify;
}

bool CHTLJSGeneratorComplete::getMinifyOutput() const {
    return minify_output_;
}

void CHTLJSGeneratorComplete::setGenerateSourceMap(bool generate) {
    generate_source_map_ = generate;
}

bool CHTLJSGeneratorComplete::getGenerateSourceMap() const {
    return generate_source_map_;
}

void CHTLJSGeneratorComplete::setErrorHandler(std::function<void(const std::string&, int, int)> handler) {
    error_handler_ = handler;
}

void CHTLJSGeneratorComplete::reportError(const std::string& message, int line, int column) {
    logError(message, line, column);
    
    if (error_handler_) {
        error_handler_(message, line, column);
    }
}

size_t CHTLJSGeneratorComplete::getGeneratedLinesCount() const {
    return generated_lines_;
}

size_t CHTLJSGeneratorComplete::getGeneratedCodeSize() const {
    return generated_code_size_;
}

std::string CHTLJSGeneratorComplete::getGenerationStatistics() const {
    std::stringstream ss;
    ss << "Generated Lines: " << generated_lines_ << "\n";
    ss << "Generated Code Size: " << generated_code_size_ << " bytes\n";
    ss << "Runtime Generated: " << (generate_runtime_ ? "Yes" : "No") << "\n";
    ss << "Output Minified: " << (minify_output_ ? "Yes" : "No") << "\n";
    return ss.str();
}

void CHTLJSGeneratorComplete::logError(const std::string& message, int line, int column) {
    std::stringstream ss;
    ss << "CHTLJSGeneratorComplete Error";
    if (line > 0) {
        ss << " at line " << line;
    }
    if (column > 0) {
        ss << ", column " << column;
    }
    ss << ": " << message;
    
    // 这里可以添加错误日志记录
}

void CHTLJSGeneratorComplete::validateNode(std::shared_ptr<CHTLJSBaseNode> node) {
    if (!node) {
        reportError("Invalid node: null pointer");
        return;
    }
    
    // 验证节点的合法性
    // 可以添加更多的验证逻辑
}

void CHTLJSGeneratorComplete::initializeCodeTemplates() {
    // 初始化代码模板
    code_templates_["function_template"] = R"(
function {{name}}({{params}}) {
    {{body}}
}
)";
    
    code_templates_["class_template"] = R"(
class {{name}} {
    constructor({{params}}) {
        {{constructor_body}}
    }
    
    {{methods}}
}
)";
}

void CHTLJSGeneratorComplete::initializeDefaultSettings() {
    // 初始化默认设置
    setGenerateRuntime(true);
    setMinifyOutput(false);
    setGenerateSourceMap(false);
}

} // namespace CHTLJS