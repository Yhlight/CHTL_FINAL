#include "CHTL/DefaultStructGenerator.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <regex>

namespace CHTL {

// DefaultStructGenerator 实现
DefaultStructGenerator::DefaultStructGenerator() {
    // 设置默认配置
    default_config_.type = DefaultStructType::STANDARD;
    default_config_.title = "CHTL Document";
    default_config_.charset = "UTF-8";
    default_config_.viewport = "width=device-width, initial-scale=1.0";
    default_config_.html_lang = "en";
    default_config_.include_doctype = true;
    default_config_.include_html_tag = true;
    default_config_.include_head_tag = true;
    default_config_.include_body_tag = true;
}

DefaultStructGenerator::~DefaultStructGenerator() = default;

std::string DefaultStructGenerator::generateDefaultStruct(const std::string& content, const DefaultStructConfig& config) const {
    switch (config.type) {
        case DefaultStructType::MINIMAL:
            return generateMinimalStruct(content);
        case DefaultStructType::STANDARD:
            return generateStandardStruct(content);
        case DefaultStructType::SPA:
            return generateSPAStruct(content);
        case DefaultStructType::DOCUMENT:
            return generateDocumentStruct(content);
        case DefaultStructType::APPLICATION:
            return generateApplicationStruct(content);
        default:
            return generateStandardStruct(content);
    }
}

std::string DefaultStructGenerator::generateMinimalStruct(const std::string& content) const {
    std::ostringstream oss;
    
    oss << "<!DOCTYPE html>\n";
    oss << "<html>\n";
    oss << "<head>\n";
    oss << "    <meta charset=\"UTF-8\">\n";
    oss << "    <title>CHTL Document</title>\n";
    oss << "</head>\n";
    oss << "<body>\n";
    oss << content << "\n";
    oss << "</body>\n";
    oss << "</html>\n";
    
    return oss.str();
}

std::string DefaultStructGenerator::generateStandardStruct(const std::string& content) const {
    std::ostringstream oss;
    
    oss << "<!DOCTYPE html>\n";
    oss << "<html lang=\"en\">\n";
    oss << "<head>\n";
    oss << "    <meta charset=\"UTF-8\">\n";
    oss << "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    oss << "    <title>CHTL Document</title>\n";
    oss << "</head>\n";
    oss << "<body>\n";
    oss << content << "\n";
    oss << "</body>\n";
    oss << "</html>\n";
    
    return oss.str();
}

std::string DefaultStructGenerator::generateSPAStruct(const std::string& content) const {
    std::ostringstream oss;
    
    oss << "<!DOCTYPE html>\n";
    oss << "<html lang=\"en\">\n";
    oss << "<head>\n";
    oss << "    <meta charset=\"UTF-8\">\n";
    oss << "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    oss << "    <title>CHTL SPA</title>\n";
    oss << "    <style>\n";
    oss << "        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }\n";
    oss << "        #app { min-height: 100vh; }\n";
    oss << "    </style>\n";
    oss << "</head>\n";
    oss << "<body>\n";
    oss << "    <div id=\"app\">\n";
    oss << content << "\n";
    oss << "    </div>\n";
    oss << "    <script>\n";
    oss << "        // SPA routing and state management\n";
    oss << "        console.log('CHTL SPA loaded');\n";
    oss << "    </script>\n";
    oss << "</body>\n";
    oss << "</html>\n";
    
    return oss.str();
}

std::string DefaultStructGenerator::generateDocumentStruct(const std::string& content) const {
    std::ostringstream oss;
    
    oss << "<!DOCTYPE html>\n";
    oss << "<html lang=\"en\">\n";
    oss << "<head>\n";
    oss << "    <meta charset=\"UTF-8\">\n";
    oss << "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    oss << "    <meta name=\"description\" content=\"CHTL Document\">\n";
    oss << "    <meta name=\"keywords\" content=\"CHTL, HTML, CSS, JavaScript\">\n";
    oss << "    <meta name=\"author\" content=\"CHTL Compiler\">\n";
    oss << "    <title>CHTL Document</title>\n";
    oss << "    <style>\n";
    oss << "        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; }\n";
    oss << "        h1, h2, h3 { color: #333; }\n";
    oss << "        p { margin-bottom: 1em; }\n";
    oss << "    </style>\n";
    oss << "</head>\n";
    oss << "<body>\n";
    oss << "    <header>\n";
    oss << "        <h1>CHTL Document</h1>\n";
    oss << "    </header>\n";
    oss << "    <main>\n";
    oss << content << "\n";
    oss << "    </main>\n";
    oss << "    <footer>\n";
    oss << "        <p>Generated by CHTL Compiler</p>\n";
    oss << "    </footer>\n";
    oss << "</body>\n";
    oss << "</html>\n";
    
    return oss.str();
}

std::string DefaultStructGenerator::generateApplicationStruct(const std::string& content) const {
    std::ostringstream oss;
    
    oss << "<!DOCTYPE html>\n";
    oss << "<html lang=\"en\">\n";
    oss << "<head>\n";
    oss << "    <meta charset=\"UTF-8\">\n";
    oss << "    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n";
    oss << "    <title>CHTL Application</title>\n";
    oss << "    <style>\n";
    oss << "        * { box-sizing: border-box; }\n";
    oss << "        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }\n";
    oss << "        .app-container { min-height: 100vh; display: flex; flex-direction: column; }\n";
    oss << "        .app-header { background: #f8f9fa; padding: 1rem; border-bottom: 1px solid #dee2e6; }\n";
    oss << "        .app-main { flex: 1; padding: 1rem; }\n";
    oss << "        .app-footer { background: #f8f9fa; padding: 1rem; border-top: 1px solid #dee2e6; text-align: center; }\n";
    oss << "    </style>\n";
    oss << "</head>\n";
    oss << "<body>\n";
    oss << "    <div class=\"app-container\">\n";
    oss << "        <header class=\"app-header\">\n";
    oss << "            <h1>CHTL Application</h1>\n";
    oss << "        </header>\n";
    oss << "        <main class=\"app-main\">\n";
    oss << content << "\n";
    oss << "        </main>\n";
    oss << "        <footer class=\"app-footer\">\n";
    oss << "            <p>&copy; 2024 CHTL Application. All rights reserved.</p>\n";
    oss << "        </footer>\n";
    oss << "    </div>\n";
    oss << "    <script>\n";
    oss << "        // Application initialization\n";
    oss << "        document.addEventListener('DOMContentLoaded', function() {\n";
    oss << "            console.log('CHTL Application loaded');\n";
    oss << "        });\n";
    oss << "    </script>\n";
    oss << "</body>\n";
    oss << "</html>\n";
    
    return oss.str();
}

bool DefaultStructGenerator::hasHTMLStructure(const std::string& content) const {
    return hasDoctype(content) || hasHTMLTag(content) || hasHeadTag(content) || hasBodyTag(content);
}

bool DefaultStructGenerator::hasDoctype(const std::string& content) const {
    std::regex doctypeRegex(R"(<!DOCTYPE\s+html\s*>?)", std::regex_constants::icase);
    return std::regex_search(content, doctypeRegex);
}

bool DefaultStructGenerator::hasHTMLTag(const std::string& content) const {
    std::regex htmlRegex(R"(<html[^>]*>)", std::regex_constants::icase);
    return std::regex_search(content, htmlRegex);
}

bool DefaultStructGenerator::hasHeadTag(const std::string& content) const {
    std::regex headRegex(R"(<head[^>]*>)", std::regex_constants::icase);
    return std::regex_search(content, headRegex);
}

bool DefaultStructGenerator::hasBodyTag(const std::string& content) const {
    std::regex bodyRegex(R"(<body[^>]*>)", std::regex_constants::icase);
    return std::regex_search(content, bodyRegex);
}

std::string DefaultStructGenerator::extractBodyContent(const std::string& content) const {
    std::regex bodyRegex(R"(<body[^>]*>(.*?)</body>)", std::regex_constants::icase | std::regex_constants::multiline);
    std::smatch match;
    
    if (std::regex_search(content, match, bodyRegex)) {
        return match[1].str();
    }
    
    return content; // 如果没有body标签，返回原内容
}

std::string DefaultStructGenerator::extractHeadContent(const std::string& content) const {
    std::regex headRegex(R"(<head[^>]*>(.*?)</head>)", std::regex_constants::icase | std::regex_constants::multiline);
    std::smatch match;
    
    if (std::regex_search(content, match, headRegex)) {
        return match[1].str();
    }
    
    return "";
}

std::string DefaultStructGenerator::extractTitle(const std::string& content) const {
    std::regex titleRegex(R"(<title[^>]*>(.*?)</title>)", std::regex_constants::icase | std::regex_constants::multiline);
    std::smatch match;
    
    if (std::regex_search(content, match, titleRegex)) {
        return match[1].str();
    }
    
    return "";
}

std::vector<std::string> DefaultStructGenerator::extractMetaTags(const std::string& content) const {
    return findAllTagContent(content, "meta");
}

std::vector<std::string> DefaultStructGenerator::extractCSSLinks(const std::string& content) const {
    return findAllTagContent(content, "link");
}

std::vector<std::string> DefaultStructGenerator::extractJSScripts(const std::string& content) const {
    return findAllTagContent(content, "script");
}

std::string DefaultStructGenerator::mergeWithDefaultStruct(const std::string& content, const DefaultStructConfig& config) const {
    if (hasHTMLStructure(content)) {
        // 如果内容已经有HTML结构，提取内容并重新包装
        std::string bodyContent = extractBodyContent(content);
        std::string headContent = extractHeadContent(content);
        
        // 合并head内容
        DefaultStructConfig mergedConfig = config;
        if (!headContent.empty()) {
            // 这里可以解析head内容并合并到配置中
            // 简化实现，直接使用原配置
        }
        
        return generateDefaultStruct(bodyContent, mergedConfig);
    } else {
        // 如果内容没有HTML结构，直接包装
        return generateDefaultStruct(content, config);
    }
}

std::string DefaultStructGenerator::wrapInDefaultStruct(const std::string& content, const DefaultStructConfig& config) const {
    return generateDefaultStruct(content, config);
}

void DefaultStructGenerator::setDefaultConfig(const DefaultStructConfig& config) {
    default_config_ = config;
}

DefaultStructConfig DefaultStructGenerator::getDefaultConfig() const {
    return default_config_;
}

DefaultStructConfig DefaultStructGenerator::getMinimalConfig() const {
    DefaultStructConfig config;
    config.type = DefaultStructType::MINIMAL;
    config.title = "CHTL Document";
    config.charset = "UTF-8";
    config.html_lang = "en";
    config.include_doctype = true;
    config.include_html_tag = true;
    config.include_head_tag = true;
    config.include_body_tag = true;
    return config;
}

DefaultStructConfig DefaultStructGenerator::getStandardConfig() const {
    DefaultStructConfig config;
    config.type = DefaultStructType::STANDARD;
    config.title = "CHTL Document";
    config.charset = "UTF-8";
    config.viewport = "width=device-width, initial-scale=1.0";
    config.html_lang = "en";
    config.include_doctype = true;
    config.include_html_tag = true;
    config.include_head_tag = true;
    config.include_body_tag = true;
    return config;
}

DefaultStructConfig DefaultStructGenerator::getSPAConfig() const {
    DefaultStructConfig config;
    config.type = DefaultStructType::SPA;
    config.title = "CHTL SPA";
    config.charset = "UTF-8";
    config.viewport = "width=device-width, initial-scale=1.0";
    config.html_lang = "en";
    config.body_class = "spa-app";
    config.include_doctype = true;
    config.include_html_tag = true;
    config.include_head_tag = true;
    config.include_body_tag = true;
    return config;
}

DefaultStructConfig DefaultStructGenerator::getDocumentConfig() const {
    DefaultStructConfig config;
    config.type = DefaultStructType::DOCUMENT;
    config.title = "CHTL Document";
    config.charset = "UTF-8";
    config.viewport = "width=device-width, initial-scale=1.0";
    config.html_lang = "en";
    config.meta_tags = {"description", "keywords", "author"};
    config.include_doctype = true;
    config.include_html_tag = true;
    config.include_head_tag = true;
    config.include_body_tag = true;
    return config;
}

DefaultStructConfig DefaultStructGenerator::getApplicationConfig() const {
    DefaultStructConfig config;
    config.type = DefaultStructType::APPLICATION;
    config.title = "CHTL Application";
    config.charset = "UTF-8";
    config.viewport = "width=device-width, initial-scale=1.0";
    config.html_lang = "en";
    config.body_class = "app-container";
    config.include_doctype = true;
    config.include_html_tag = true;
    config.include_head_tag = true;
    config.include_body_tag = true;
    return config;
}

std::string DefaultStructGenerator::generateDoctype() const {
    return "<!DOCTYPE html>";
}

std::string DefaultStructGenerator::generateHTMLTag(const DefaultStructConfig& config) const {
    std::ostringstream oss;
    oss << "<html";
    if (!config.html_lang.empty()) {
        oss << " lang=\"" << config.html_lang << "\"";
    }
    oss << ">";
    return oss.str();
}

std::string DefaultStructGenerator::generateHeadTag(const DefaultStructConfig& config) const {
    std::ostringstream oss;
    oss << "<head>\n";
    oss << generateMetaTags(config);
    oss << "    <title>" << config.title << "</title>\n";
    oss << generateCSSLinks(config);
    oss << "</head>";
    return oss.str();
}

std::string DefaultStructGenerator::generateBodyTag(const DefaultStructConfig& config) const {
    std::ostringstream oss;
    oss << "<body";
    if (!config.body_class.empty()) {
        oss << " class=\"" << config.body_class << "\"";
    }
    oss << ">";
    return oss.str();
}

std::string DefaultStructGenerator::generateMetaTags(const DefaultStructConfig& config) const {
    std::ostringstream oss;
    
    oss << "    <meta charset=\"" << config.charset << "\">\n";
    
    if (!config.viewport.empty()) {
        oss << "    <meta name=\"viewport\" content=\"" << config.viewport << "\">\n";
    }
    
    for (const auto& meta : config.meta_tags) {
        oss << "    <meta name=\"" << meta << "\" content=\"CHTL " << meta << "\">\n";
    }
    
    return oss.str();
}

std::string DefaultStructGenerator::generateCSSLinks(const DefaultStructConfig& config) const {
    std::ostringstream oss;
    
    for (const auto& css : config.css_links) {
        oss << "    <link rel=\"stylesheet\" href=\"" << css << "\">\n";
    }
    
    return oss.str();
}

std::string DefaultStructGenerator::generateJSScripts(const DefaultStructConfig& config) const {
    std::ostringstream oss;
    
    for (const auto& js : config.js_scripts) {
        oss << "    <script src=\"" << js << "\"></script>\n";
    }
    
    return oss.str();
}

std::string DefaultStructGenerator::findTagContent(const std::string& content, const std::string& tagName) const {
    std::string pattern = "<" + tagName + "[^>]*>(.*?)</" + tagName + ">";
    std::regex tagRegex(pattern, std::regex_constants::icase | std::regex_constants::multiline);
    std::smatch match;
    
    if (std::regex_search(content, match, tagRegex)) {
        return match[1].str();
    }
    
    return "";
}

std::vector<std::string> DefaultStructGenerator::findAllTagContent(const std::string& content, const std::string& tagName) const {
    std::vector<std::string> results;
    std::string pattern = "<" + tagName + "[^>]*>.*?</" + tagName + ">";
    std::regex tagRegex(pattern, std::regex_constants::icase | std::regex_constants::multiline);
    std::sregex_iterator begin(content.begin(), content.end(), tagRegex);
    std::sregex_iterator end;
    
    for (auto it = begin; it != end; ++it) {
        results.push_back(it->str());
    }
    
    return results;
}

bool DefaultStructGenerator::containsTag(const std::string& content, const std::string& tagName) const {
    std::string pattern = "<" + tagName + "[^>]*>";
    std::regex tagRegex(pattern, std::regex_constants::icase);
    return std::regex_search(content, tagRegex);
}

std::string DefaultStructGenerator::cleanContent(const std::string& content) const {
    std::string result = content;
    
    // 移除多余的空白字符
    result = std::regex_replace(result, std::regex(R"(\s+)"), " ");
    
    // 移除首尾空白
    result.erase(0, result.find_first_not_of(" \t\n\r"));
    result.erase(result.find_last_not_of(" \t\n\r") + 1);
    
    return result;
}

std::string DefaultStructGenerator::processTemplate(const std::string& template_str, const std::map<std::string, std::string>& variables) const {
    return replacePlaceholders(template_str, variables);
}

std::string DefaultStructGenerator::replacePlaceholders(const std::string& str, const std::map<std::string, std::string>& replacements) const {
    std::string result = str;
    
    for (const auto& pair : replacements) {
        std::string placeholder = "{{" + pair.first + "}}";
        size_t pos = 0;
        while ((pos = result.find(placeholder, pos)) != std::string::npos) {
            result.replace(pos, placeholder.length(), pair.second);
            pos += pair.second.length();
        }
    }
    
    return result;
}

// DefaultStructManager 实现
DefaultStructManager::DefaultStructManager() 
    : default_struct_enabled_(false)
    , struct_type_(DefaultStructType::STANDARD) {
    initializePresets();
}

DefaultStructManager::~DefaultStructManager() = default;

void DefaultStructManager::enableDefaultStruct(bool enabled) {
    default_struct_enabled_ = enabled;
}

bool DefaultStructManager::isDefaultStructEnabled() const {
    return default_struct_enabled_;
}

void DefaultStructManager::setStructType(DefaultStructType type) {
    struct_type_ = type;
    config_.type = type;
}

DefaultStructType DefaultStructManager::getStructType() const {
    return struct_type_;
}

void DefaultStructManager::setConfig(const DefaultStructConfig& config) {
    config_ = config;
}

DefaultStructConfig DefaultStructManager::getConfig() const {
    return config_;
}

std::string DefaultStructManager::processContent(const std::string& content) const {
    if (!default_struct_enabled_) {
        return content;
    }
    
    return generator_.generateDefaultStruct(content, config_);
}

std::string DefaultStructManager::processContentWithConfig(const std::string& content, const DefaultStructConfig& config) const {
    return generator_.generateDefaultStruct(content, config);
}

void DefaultStructManager::loadPreset(const std::string& presetName) {
    auto it = presets_.find(presetName);
    if (it != presets_.end()) {
        config_ = it->second;
        struct_type_ = config_.type;
    }
}

std::vector<std::string> DefaultStructManager::getAvailablePresets() const {
    std::vector<std::string> presetNames;
    for (const auto& pair : presets_) {
        presetNames.push_back(pair.first);
    }
    return presetNames;
}

bool DefaultStructManager::validateConfig(const DefaultStructConfig& config) const {
    return !config.title.empty() && !config.charset.empty();
}

std::vector<std::string> DefaultStructManager::getConfigValidationErrors(const DefaultStructConfig& config) const {
    std::vector<std::string> errors;
    
    if (config.title.empty()) {
        errors.push_back("Title cannot be empty");
    }
    
    if (config.charset.empty()) {
        errors.push_back("Charset cannot be empty");
    }
    
    return errors;
}

void DefaultStructManager::initializePresets() {
    presets_["minimal"] = generator_.getMinimalConfig();
    presets_["standard"] = generator_.getStandardConfig();
    presets_["spa"] = generator_.getSPAConfig();
    presets_["document"] = generator_.getDocumentConfig();
    presets_["application"] = generator_.getApplicationConfig();
}

DefaultStructConfig DefaultStructManager::createPresetConfig(const std::string& presetName) const {
    if (presetName == "minimal") {
        return generator_.getMinimalConfig();
    } else if (presetName == "standard") {
        return generator_.getStandardConfig();
    } else if (presetName == "spa") {
        return generator_.getSPAConfig();
    } else if (presetName == "document") {
        return generator_.getDocumentConfig();
    } else if (presetName == "application") {
        return generator_.getApplicationConfig();
    }
    
    return generator_.getStandardConfig();
}

// CompilerOptionProcessor 实现
CompilerOptionProcessor::CompilerOptionProcessor() = default;

CompilerOptionProcessor::~CompilerOptionProcessor() = default;

bool CompilerOptionProcessor::parseDefaultStructOption(const std::string& option) const {
    return option.find("--default-struct") != std::string::npos;
}

DefaultStructConfig CompilerOptionProcessor::parseDefaultStructConfig(const std::string& option) const {
    DefaultStructConfig config;
    
    if (option.find("--default-struct") != std::string::npos) {
        // 解析选项参数
        auto params = parseOptionParameters(option);
        
        // 设置结构类型
        auto typeIt = params.find("type");
        if (typeIt != params.end()) {
            config.type = parseStructType(typeIt->second);
        }
        
        // 设置标题
        auto titleIt = params.find("title");
        if (titleIt != params.end()) {
            config.title = titleIt->second;
        }
        
        // 设置语言
        auto langIt = params.find("lang");
        if (langIt != params.end()) {
            config.html_lang = langIt->second;
        }
    }
    
    return config;
}

bool CompilerOptionProcessor::isValidDefaultStructOption(const std::string& option) const {
    if (!parseDefaultStructOption(option)) {
        return false;
    }
    
    // 解析参数并验证
    auto params = parseOptionParameters(option);
    
    // 验证结构类型
    auto typeIt = params.find("type");
    if (typeIt != params.end()) {
        if (!isStructTypeValid(typeIt->second)) {
            return false;
        }
    }
    
    return true;
}

std::vector<std::string> CompilerOptionProcessor::getOptionValidationErrors(const std::string& option) const {
    std::vector<std::string> errors;
    
    if (!parseDefaultStructOption(option)) {
        errors.push_back("Not a valid --default-struct option");
        return errors;
    }
    
    auto params = parseOptionParameters(option);
    
    auto typeIt = params.find("type");
    if (typeIt != params.end()) {
        if (!isStructTypeValid(typeIt->second)) {
            errors.push_back("Invalid structure type: " + typeIt->second);
        }
    }
    
    return errors;
}

std::string CompilerOptionProcessor::processDefaultStructOption(const std::string& content, const std::string& option) const {
    if (!parseDefaultStructOption(option)) {
        return content;
    }
    
    auto config = parseDefaultStructConfig(option);
    DefaultStructGenerator generator;
    return generator.generateDefaultStruct(content, config);
}

std::string CompilerOptionProcessor::processDefaultStructOptionWithConfig(const std::string& content, const DefaultStructConfig& config) const {
    DefaultStructGenerator generator;
    return generator.generateDefaultStruct(content, config);
}

std::string CompilerOptionProcessor::getDefaultStructOptionHelp() const {
    return R"(
--default-struct [options]
    Generate HTML with default structure

Options:
    --type=TYPE        Structure type (minimal, standard, spa, document, application)
    --title=TITLE      Document title
    --lang=LANG        HTML language attribute

Examples:
    --default-struct
    --default-struct --type=spa --title="My SPA"
    --default-struct --type=document --lang=zh-CN
)";
}

std::vector<std::string> CompilerOptionProcessor::getDefaultStructOptionExamples() const {
    return {
        "--default-struct",
        "--default-struct --type=spa --title=\"My SPA\"",
        "--default-struct --type=document --lang=zh-CN",
        "--default-struct --type=application --title=\"CHTL App\""
    };
}

DefaultStructType CompilerOptionProcessor::parseStructType(const std::string& typeStr) const {
    if (typeStr == "minimal") return DefaultStructType::MINIMAL;
    if (typeStr == "standard") return DefaultStructType::STANDARD;
    if (typeStr == "spa") return DefaultStructType::SPA;
    if (typeStr == "document") return DefaultStructType::DOCUMENT;
    if (typeStr == "application") return DefaultStructType::APPLICATION;
    return DefaultStructType::STANDARD;
}

std::map<std::string, std::string> CompilerOptionProcessor::parseOptionParameters(const std::string& option) const {
    std::map<std::string, std::string> params;
    
    std::regex paramRegex(R"(--(\w+)=([^-\s]+))");
    std::sregex_iterator begin(option.begin(), option.end(), paramRegex);
    std::sregex_iterator end;
    
    for (auto it = begin; it != end; ++it) {
        std::string key = (*it)[1].str();
        std::string value = (*it)[2].str();
        params[key] = value;
    }
    
    return params;
}

bool CompilerOptionProcessor::isStructTypeValid(const std::string& typeStr) const {
    auto validTypes = getValidStructTypes();
    return std::find(validTypes.begin(), validTypes.end(), typeStr) != validTypes.end();
}

std::vector<std::string> CompilerOptionProcessor::getValidStructTypes() const {
    return {"minimal", "standard", "spa", "document", "application"};
}

} // namespace CHTL