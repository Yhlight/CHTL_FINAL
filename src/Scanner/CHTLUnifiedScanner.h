#ifndef CHTL_UNIFIED_SCANNER_H
#define CHTL_UNIFIED_SCANNER_H

#include <string>
#include <vector>
#include <map>
#include <sstream>

namespace CHTL {

// Represents the different language fragments the scanner can identify.
enum class FragmentType {
    CHTL,
    CSS,                // For downstream compilers, not generated by scanner for style blocks.
    JS,                 // For downstream compilers, not generated by scanner for script blocks.
    CHTL_JS,            // For global script blocks, which are scanned for CHTL JS features.
    CHTL_STYLE_BLOCK,   // For ALL style blocks. Their content is not plain CSS and must be parsed by the CHTL Parser.
    CHTL_SCRIPT_BLOCK,  // For local (nested) script blocks, scanned for CHTL JS features.
    UNKNOWN
};

// A fragment of code identified by the scanner.
struct CodeFragment {
    std::string content;
    FragmentType type;
};

class CHTLUnifiedScanner {
public:
    explicit CHTLUnifiedScanner(const std::string& source);
    std::vector<CodeFragment> scan();

    const std::map<std::string, std::string>& getPlaceholderMap() const;

    enum class ParsingState {
        DEFAULT,
        IN_STRING,
        IN_SINGLE_LINE_COMMENT,
        IN_MULTI_LINE_COMMENT,
    };

private:
    // Main processing logic
    void process();

    // Recognizer infrastructure
    using BlockRecognizer = bool (CHTLUnifiedScanner::*)(size_t&);
    static const std::vector<BlockRecognizer> RECOGNIZERS;
    bool recognizeStyleBlock(size_t& last_flush_pos);
    bool recognizeScriptBlock(size_t& last_flush_pos);
    bool recognizeBracketBlock(size_t& last_flush_pos);

    // Keyword and block identification helpers
    bool isKeywordAt(size_t pos, const std::string& keyword);
    size_t findEndOfBlock(size_t start_pos, char open_brace, char close_brace);

    // CHTL JS/JS separation logic
    std::string scanJsAndChtlJs(const std::string& script_content);
    std::string createPlaceholder(const std::string& content);

    // Helper methods
    void addFragment(const std::string& content, FragmentType type, size_t& last_flush_pos);

    // Member variables
    const std::string& source_;
    std::vector<CodeFragment> fragments_;
    std::map<std::string, std::string> placeholder_map_;

    size_t cursor_ = 0;
    int placeholder_id_ = 0;
    int brace_level_ = 0;

    // State machine for the main process loop
    ParsingState state_ = ParsingState::DEFAULT;
    char string_delimiter_ = '\0';
};

} // namespace CHTL

#endif // CHTL_UNIFIED_SCANNER_H
