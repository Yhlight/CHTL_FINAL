#include "CHTLJSGenerator.h"
#include <sstream>
#include <algorithm>
#include <cctype>
#include <regex>

namespace CHTL_JS {

CHTLJSGenerator::CHTLJSGenerator() 
    : debugMode(false), strictMode(false), minifyOutput(false), beautifyOutput(false),
      includeComments(true), includeSourceMaps(false), indentLevel(0), indentString("  "),
      currentScope("global"), generatedLines(0), generatedCharacters(0),
      outputFormat("javascript"), languageVersion("1.0.0") {
}

std::string CHTLJSGenerator::generate(std::shared_ptr<CHTLJSBaseNode> ast) {
    if (!ast) {
        addError("AST is null");
        return "";
    }
    
    reset();
    std::string result = generateNode(ast);
    
    if (minifyOutput) {
        result = minifyCode(result);
    } else if (beautifyOutput) {
        result = beautifyCode(result);
    }
    
    updateLineCount(result);
    updateCharacterCount(result);
    
    return result;
}

std::string CHTLJSGenerator::generateProgram(std::shared_ptr<CHTLJSBaseNode> program) {
    if (!program || program->getNodeType() != CHTLJSNodeType::MODULE_DECLARATION) {
        addError("Invalid program node");
        return "";
    }
    
    std::ostringstream oss;
    
    // 生成文件头注释
    if (includeComments) {
        oss << "// Generated by CHTL JS Generator v" << languageVersion << "\n";
        oss << "// " << generatedLines << " lines, " << generatedCharacters << " characters\n\n";
    }
    
    // 生成严格模式指令
    if (strictMode) {
        oss << "\"use strict\";\n\n";
    }
    
    // 生成程序内容
    std::string content = generateChildren(program);
    oss << content;
    
    return oss.str();
}

std::string CHTLJSGenerator::generateStatement(std::shared_ptr<CHTLJSBaseNode> statement) {
    if (!statement) {
        addError("Statement is null");
        return "";
    }
    
    switch (statement->getNodeType()) {
        case CHTLJSNodeType::EXPRESSION_STATEMENT:
            return generateExpressionStatement(statement);
        case CHTLJSNodeType::BLOCK_STATEMENT:
            return generateBlockStatement(statement);
        case CHTLJSNodeType::IF_STATEMENT:
            return generateIfStatement(statement);
        case CHTLJSNodeType::FOR_STATEMENT:
            return generateForStatement(statement);
        case CHTLJSNodeType::WHILE_STATEMENT:
            return generateWhileStatement(statement);
        case CHTLJSNodeType::DO_WHILE_STATEMENT:
            return generateDoWhileStatement(statement);
        case CHTLJSNodeType::SWITCH_STATEMENT:
            return generateSwitchStatement(statement);
        case CHTLJSNodeType::CASE_STATEMENT:
            return generateCaseStatement(statement);
        case CHTLJSNodeType::DEFAULT_STATEMENT:
            return generateDefaultStatement(statement);
        case CHTLJSNodeType::BREAK_STATEMENT:
            return generateBreakStatement(statement);
        case CHTLJSNodeType::CONTINUE_STATEMENT:
            return generateContinueStatement(statement);
        case CHTLJSNodeType::RETURN_STATEMENT:
            return generateReturnStatement(statement);
        case CHTLJSNodeType::THROW_STATEMENT:
            return generateThrowStatement(statement);
        case CHTLJSNodeType::TRY_STATEMENT:
            return generateTryStatement(statement);
        case CHTLJSNodeType::CATCH_STATEMENT:
            return generateCatchStatement(statement);
        case CHTLJSNodeType::FINALLY_STATEMENT:
            return generateFinallyStatement(statement);
        default:
            addError("Unknown statement type: " + statement->getNodeTypeName());
            return "";
    }
}

std::string CHTLJSGenerator::generateExpression(std::shared_ptr<CHTLJSBaseNode> expression) {
    if (!expression) {
        addError("Expression is null");
        return "";
    }
    
    switch (expression->getNodeType()) {
        case CHTLJSNodeType::LITERAL:
            return generatePrimaryExpression(expression);
        case CHTLJSNodeType::IDENTIFIER:
            return generatePrimaryExpression(expression);
        case CHTLJSNodeType::BINARY_EXPRESSION:
            return generateBinaryExpression(expression);
        case CHTLJSNodeType::UNARY_EXPRESSION:
            return generateUnaryExpression(expression);
        case CHTLJSNodeType::TERNARY_EXPRESSION:
            return generateTernaryExpression(expression);
        case CHTLJSNodeType::CALL_EXPRESSION:
            return generateCallExpression(expression);
        case CHTLJSNodeType::MEMBER_EXPRESSION:
            return generateMemberExpression(expression);
        case CHTLJSNodeType::ARRAY_EXPRESSION:
            return generateArrayExpression(expression);
        case CHTLJSNodeType::OBJECT_EXPRESSION:
            return generateObjectExpression(expression);
        case CHTLJSNodeType::FUNCTION_EXPRESSION:
            return generateFunctionExpression(expression);
        case CHTLJSNodeType::ARROW_FUNCTION_EXPRESSION:
            return generateArrowFunctionExpression(expression);
        case CHTLJSNodeType::ENHANCED_SELECTOR:
            return generateEnhancedSelector(expression);
        case CHTLJSNodeType::VIRTUAL_OBJECT:
            return generateVirtualObject(expression);
        case CHTLJSNodeType::LISTEN_EXPRESSION:
            return generateListenExpression(expression);
        case CHTLJSNodeType::DELEGATE_EXPRESSION:
            return generateDelegateExpression(expression);
        case CHTLJSNodeType::ANIMATE_EXPRESSION:
            return generateAnimateExpression(expression);
        case CHTLJSNodeType::ROUTER_EXPRESSION:
            return generateRouterExpression(expression);
        case CHTLJSNodeType::FILELOADER_EXPRESSION:
            return generateFileloaderExpression(expression);
        case CHTLJSNodeType::UTIL_EXPRESSION:
            return generateUtilExpression(expression);
        default:
            addError("Unknown expression type: " + expression->getNodeTypeName());
            return "";
    }
}

std::string CHTLJSGenerator::generateDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) {
    if (!declaration) {
        addError("Declaration is null");
        return "";
    }
    
    switch (declaration->getNodeType()) {
        case CHTLJSNodeType::VARIABLE_DECLARATION:
            return generateVariableDeclaration(declaration);
        case CHTLJSNodeType::FUNCTION_DECLARATION:
            return generateFunctionDeclaration(declaration);
        case CHTLJSNodeType::CLASS_DECLARATION:
            return generateClassDeclaration(declaration);
        case CHTLJSNodeType::INTERFACE_DECLARATION:
            return generateInterfaceDeclaration(declaration);
        case CHTLJSNodeType::ENUM_DECLARATION:
            return generateEnumDeclaration(declaration);
        case CHTLJSNodeType::NAMESPACE_DECLARATION:
            return generateNamespaceDeclaration(declaration);
        case CHTLJSNodeType::MODULE_DECLARATION:
            return generateModuleDeclaration(declaration);
        case CHTLJSNodeType::IMPORT_DECLARATION:
            return generateImportDeclaration(declaration);
        case CHTLJSNodeType::EXPORT_DECLARATION:
            return generateExportDeclaration(declaration);
        default:
            addError("Unknown declaration type: " + declaration->getNodeTypeName());
            return "";
    }
}

// 语句生成实现
std::string CHTLJSGenerator::generateExpressionStatement(std::shared_ptr<CHTLJSBaseNode> statement) {
    auto children = statement->getChildren();
    if (children.empty()) {
        addError("Expression statement has no children");
        return "";
    }
    
    std::string expression = generateExpression(children[0]);
    return expression + ";";
}

std::string CHTLJSGenerator::generateBlockStatement(std::shared_ptr<CHTLJSBaseNode> statement) {
    std::ostringstream oss;
    oss << "{\n";
    
    increaseIndent();
    enterScope("block");
    
    auto children = statement->getChildren();
    for (const auto& child : children) {
        if (child) {
            std::string childCode = generateStatement(child);
            oss << getIndent() << childCode << "\n";
        }
    }
    
    exitScope();
    decreaseIndent();
    
    oss << getIndent() << "}";
    return oss.str();
}

std::string CHTLJSGenerator::generateIfStatement(std::shared_ptr<CHTLJSBaseNode> statement) {
    auto children = statement->getChildren();
    if (children.size() < 2) {
        addError("If statement must have at least condition and consequent");
        return "";
    }
    
    std::ostringstream oss;
    oss << "if (";
    oss << generateExpression(children[0]);
    oss << ") ";
    
    if (children[1]->getNodeType() == CHTLJSNodeType::BLOCK_STATEMENT) {
        oss << generateStatement(children[1]);
    } else {
        oss << "{\n";
        increaseIndent();
        oss << getIndent() << generateStatement(children[1]) << "\n";
        decreaseIndent();
        oss << getIndent() << "}";
    }
    
    if (children.size() > 2) {
        oss << " else ";
        if (children[2]->getNodeType() == CHTLJSNodeType::BLOCK_STATEMENT) {
            oss << generateStatement(children[2]);
        } else {
            oss << "{\n";
            increaseIndent();
            oss << getIndent() << generateStatement(children[2]) << "\n";
            decreaseIndent();
            oss << getIndent() << "}";
        }
    }
    
    return oss.str();
}

// 表达式生成实现
std::string CHTLJSGenerator::generatePrimaryExpression(std::shared_ptr<CHTLJSBaseNode> expression) {
    if (expression->getNodeType() == CHTLJSNodeType::LITERAL) {
        return expression->getValue();
    } else if (expression->getNodeType() == CHTLJSNodeType::IDENTIFIER) {
        return expression->getName();
    }
    
    return expression->getValue();
}

std::string CHTLJSGenerator::generateBinaryExpression(std::shared_ptr<CHTLJSBaseNode> expression) {
    auto children = expression->getChildren();
    if (children.size() != 2) {
        addError("Binary expression must have exactly 2 children");
        return "";
    }
    
    std::string left = generateExpression(children[0]);
    std::string right = generateExpression(children[1]);
    std::string operator_ = expression->getValue();
    
    return "(" + left + " " + operator_ + " " + right + ")";
}

std::string CHTLJSGenerator::generateUnaryExpression(std::shared_ptr<CHTLJSBaseNode> expression) {
    auto children = expression->getChildren();
    if (children.empty()) {
        addError("Unary expression must have at least one child");
        return "";
    }
    
    std::string operand = generateExpression(children[0]);
    std::string operator_ = expression->getValue();
    
    return operator_ + operand;
}

// CHTL JS特有语法生成实现
std::string CHTLJSGenerator::generateEnhancedSelector(std::shared_ptr<CHTLJSBaseNode> selector) {
    std::string selectorValue = selector->getValue();
    return processEnhancedSelector(selectorValue);
}

std::string CHTLJSGenerator::generateVirtualObject(std::shared_ptr<CHTLJSBaseNode> virtualObject) {
    std::string name = virtualObject->getName();
    auto children = virtualObject->getChildren();
    
    if (children.empty()) {
        addError("Virtual object must have a value");
        return "";
    }
    
    return processVirtualObject(name, children[0]);
}

std::string CHTLJSGenerator::generateListenExpression(std::shared_ptr<CHTLJSBaseNode> listen) {
    return processListenExpression(listen);
}

// 其他生成方法的简化实现
std::string CHTLJSGenerator::generateForStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateWhileStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateDoWhileStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateSwitchStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateCaseStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateDefaultStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateBreakStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateContinueStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateReturnStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateThrowStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateTryStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateCatchStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateFinallyStatement(std::shared_ptr<CHTLJSBaseNode> statement) { return ""; }
std::string CHTLJSGenerator::generateTernaryExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateCallExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateMemberExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateArrayExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateObjectExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateFunctionExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateArrowFunctionExpression(std::shared_ptr<CHTLJSBaseNode> expression) { return ""; }
std::string CHTLJSGenerator::generateVariableDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateFunctionDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateClassDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateInterfaceDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateEnumDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateNamespaceDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateModuleDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateImportDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateExportDeclaration(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateDelegateExpression(std::shared_ptr<CHTLJSBaseNode> delegate) { return ""; }
std::string CHTLJSGenerator::generateAnimateExpression(std::shared_ptr<CHTLJSBaseNode> animate) { return ""; }
std::string CHTLJSGenerator::generateRouterExpression(std::shared_ptr<CHTLJSBaseNode> router) { return ""; }
std::string CHTLJSGenerator::generateFileloaderExpression(std::shared_ptr<CHTLJSBaseNode> fileloader) { return ""; }
std::string CHTLJSGenerator::generateUtilExpression(std::shared_ptr<CHTLJSBaseNode> util) { return ""; }
std::string CHTLJSGenerator::generateDeclarationSyntax(std::shared_ptr<CHTLJSBaseNode> declaration) { return ""; }
std::string CHTLJSGenerator::generateKeyValuePairs(std::shared_ptr<CHTLJSBaseNode> pairs) { return ""; }
std::string CHTLJSGenerator::generateUnorderedPairs(std::shared_ptr<CHTLJSBaseNode> pairs) { return ""; }
std::string CHTLJSGenerator::generateOptionalPairs(std::shared_ptr<CHTLJSBaseNode> pairs) { return ""; }
std::string CHTLJSGenerator::generateChainExpression(std::shared_ptr<CHTLJSBaseNode> chain) { return ""; }
std::string CHTLJSGenerator::generateUnquotedLiteral(std::shared_ptr<CHTLJSBaseNode> literal) { return ""; }

// 错误处理实现
void CHTLJSGenerator::addError(const std::string& error) {
    errors.push_back(error);
}

void CHTLJSGenerator::addWarning(const std::string& warning) {
    warnings.push_back(warning);
}

void CHTLJSGenerator::clearErrors() {
    errors.clear();
}

void CHTLJSGenerator::clearWarnings() {
    warnings.clear();
}

void CHTLJSGenerator::reset() {
    resetScope();
    clearErrors();
    clearWarnings();
    resetStatistics();
    indentLevel = 0;
    currentScope = "global";
}

void CHTLJSGenerator::resetScope() {
    scopeStack.clear();
    variables.clear();
    functions.clear();
    classes.clear();
    modules.clear();
    enterScope("global");
}

void CHTLJSGenerator::enterScope(const std::string& scope) {
    scopeStack.push_back(scope);
    currentScope = scope;
}

void CHTLJSGenerator::exitScope() {
    if (!scopeStack.empty()) {
        scopeStack.pop_back();
        currentScope = scopeStack.empty() ? "global" : scopeStack.back();
    }
}

std::string CHTLJSGenerator::getDebugInfo() const {
    std::ostringstream oss;
    oss << "CHTLJSGenerator Debug Info:\n";
    oss << "Debug Mode: " << (debugMode ? "ON" : "OFF") << "\n";
    oss << "Strict Mode: " << (strictMode ? "ON" : "OFF") << "\n";
    oss << "Minify Output: " << (minifyOutput ? "ON" : "OFF") << "\n";
    oss << "Beautify Output: " << (beautifyOutput ? "ON" : "OFF") << "\n";
    oss << "Include Comments: " << (includeComments ? "ON" : "OFF") << "\n";
    oss << "Include Source Maps: " << (includeSourceMaps ? "ON" : "OFF") << "\n";
    oss << "Output Format: " << outputFormat << "\n";
    oss << "Language Version: " << languageVersion << "\n";
    oss << "Current Scope: " << currentScope << "\n";
    oss << "Indent Level: " << indentLevel << "\n";
    oss << "Generated Lines: " << generatedLines << "\n";
    oss << "Generated Characters: " << generatedCharacters << "\n";
    oss << "Errors: " << errors.size() << "\n";
    oss << "Warnings: " << warnings.size() << "\n";
    return oss.str();
}

void CHTLJSGenerator::printDebugInfo() const {
    std::cout << getDebugInfo() << std::endl;
}

int CHTLJSGenerator::getGeneratedLines() const {
    return generatedLines;
}

int CHTLJSGenerator::getGeneratedCharacters() const {
    return generatedCharacters;
}

std::map<std::string, int> CHTLJSGenerator::getFeatureUsage() const {
    return featureUsage;
}

void CHTLJSGenerator::resetStatistics() {
    generatedLines = 0;
    generatedCharacters = 0;
    featureUsage.clear();
}

bool CHTLJSGenerator::validateOutput(const std::string& output) const {
    return !output.empty();
}

std::vector<std::string> CHTLJSGenerator::validateGeneratedCode(const std::string& code) const {
    std::vector<std::string> errors;
    
    if (code.empty()) {
        errors.push_back("Generated code is empty");
    }
    
    if (outputFormat == "javascript") {
        if (!validateJavaScript(code)) {
            errors.push_back("Invalid JavaScript syntax");
        }
    } else if (outputFormat == "chtljs") {
        if (!validateCHTLJS(code)) {
            errors.push_back("Invalid CHTL JS syntax");
        }
    } else if (outputFormat == "html") {
        if (!validateHTML(code)) {
            errors.push_back("Invalid HTML syntax");
        }
    } else if (outputFormat == "css") {
        if (!validateCSS(code)) {
            errors.push_back("Invalid CSS syntax");
        }
    }
    
    return errors;
}

// 辅助方法实现
std::string CHTLJSGenerator::getIndent() const {
    return std::string(indentLevel * indentString.length(), ' ');
}

void CHTLJSGenerator::increaseIndent() {
    indentLevel++;
}

void CHTLJSGenerator::decreaseIndent() {
    if (indentLevel > 0) {
        indentLevel--;
    }
}

std::string CHTLJSGenerator::formatCode(const std::string& code) const {
    if (minifyOutput) {
        return minifyCode(code);
    } else if (beautifyOutput) {
        return beautifyCode(code);
    }
    return code;
}

std::string CHTLJSGenerator::minifyCode(const std::string& code) const {
    std::string result = code;
    result = removeWhitespace(result);
    result = removeComments(result);
    result = removeEmptyLines(result);
    result = compressIdentifiers(result);
    return result;
}

std::string CHTLJSGenerator::beautifyCode(const std::string& code) const {
    std::string result = code;
    result = addIndentation(result);
    result = addLineBreaks(result);
    result = addSpacing(result);
    result = formatBrackets(result);
    result = formatOperators(result);
    return result;
}

// 代码生成辅助实现
std::string CHTLJSGenerator::generateNode(std::shared_ptr<CHTLJSBaseNode> node) {
    if (!node) {
        return "";
    }
    
    switch (node->getNodeType()) {
        case CHTLJSNodeType::MODULE_DECLARATION:
            return generateProgram(node);
        case CHTLJSNodeType::EXPRESSION_STATEMENT:
        case CHTLJSNodeType::BLOCK_STATEMENT:
        case CHTLJSNodeType::IF_STATEMENT:
        case CHTLJSNodeType::FOR_STATEMENT:
        case CHTLJSNodeType::WHILE_STATEMENT:
        case CHTLJSNodeType::DO_WHILE_STATEMENT:
        case CHTLJSNodeType::SWITCH_STATEMENT:
        case CHTLJSNodeType::CASE_STATEMENT:
        case CHTLJSNodeType::DEFAULT_STATEMENT:
        case CHTLJSNodeType::BREAK_STATEMENT:
        case CHTLJSNodeType::CONTINUE_STATEMENT:
        case CHTLJSNodeType::RETURN_STATEMENT:
        case CHTLJSNodeType::THROW_STATEMENT:
        case CHTLJSNodeType::TRY_STATEMENT:
        case CHTLJSNodeType::CATCH_STATEMENT:
        case CHTLJSNodeType::FINALLY_STATEMENT:
            return generateStatement(node);
        case CHTLJSNodeType::LITERAL:
        case CHTLJSNodeType::IDENTIFIER:
        case CHTLJSNodeType::BINARY_EXPRESSION:
        case CHTLJSNodeType::UNARY_EXPRESSION:
        case CHTLJSNodeType::TERNARY_EXPRESSION:
        case CHTLJSNodeType::CALL_EXPRESSION:
        case CHTLJSNodeType::MEMBER_EXPRESSION:
        case CHTLJSNodeType::ARRAY_EXPRESSION:
        case CHTLJSNodeType::OBJECT_EXPRESSION:
        case CHTLJSNodeType::FUNCTION_EXPRESSION:
        case CHTLJSNodeType::ARROW_FUNCTION_EXPRESSION:
        case CHTLJSNodeType::ENHANCED_SELECTOR:
        case CHTLJSNodeType::VIRTUAL_OBJECT:
        case CHTLJSNodeType::LISTEN_EXPRESSION:
        case CHTLJSNodeType::DELEGATE_EXPRESSION:
        case CHTLJSNodeType::ANIMATE_EXPRESSION:
        case CHTLJSNodeType::ROUTER_EXPRESSION:
        case CHTLJSNodeType::FILELOADER_EXPRESSION:
        case CHTLJSNodeType::UTIL_EXPRESSION:
            return generateExpression(node);
        case CHTLJSNodeType::VARIABLE_DECLARATION:
        case CHTLJSNodeType::FUNCTION_DECLARATION:
        case CHTLJSNodeType::CLASS_DECLARATION:
        case CHTLJSNodeType::INTERFACE_DECLARATION:
        case CHTLJSNodeType::ENUM_DECLARATION:
        case CHTLJSNodeType::NAMESPACE_DECLARATION:
        case CHTLJSNodeType::IMPORT_DECLARATION:
        case CHTLJSNodeType::EXPORT_DECLARATION:
            return generateDeclaration(node);
        default:
            addError("Unknown node type: " + node->getNodeTypeName());
            return "";
    }
}

std::string CHTLJSGenerator::generateChildren(std::shared_ptr<CHTLJSBaseNode> node) {
    std::ostringstream oss;
    auto children = node->getChildren();
    
    for (const auto& child : children) {
        if (child) {
            std::string childCode = generateNode(child);
            if (!childCode.empty()) {
                oss << childCode;
                if (!minifyOutput) {
                    oss << "\n";
                }
            }
        }
    }
    
    return oss.str();
}

std::string CHTLJSGenerator::generateAttributes(std::shared_ptr<CHTLJSBaseNode> node) {
    std::ostringstream oss;
    auto attributes = node->getAttributes();
    
    if (!attributes.empty()) {
        oss << " [";
        bool first = true;
        for (const auto& pair : attributes) {
            if (!first) oss << ", ";
            oss << pair.first << "='" << pair.second << "'";
            first = false;
        }
        oss << "]";
    }
    
    return oss.str();
}

std::string CHTLJSGenerator::generateComments(std::shared_ptr<CHTLJSBaseNode> node) {
    if (!includeComments) {
        return "";
    }
    
    std::ostringstream oss;
    auto comments = node->getComments();
    
    for (const auto& comment : comments) {
        oss << "// " << comment << "\n";
    }
    
    return oss.str();
}

std::string CHTLJSGenerator::generateDirectives(std::shared_ptr<CHTLJSBaseNode> node) {
    std::ostringstream oss;
    auto directives = node->getDirectives();
    
    for (const auto& directive : directives) {
        oss << "// " << directive << "\n";
    }
    
    return oss.str();
}

// 类型转换实现
std::string CHTLJSGenerator::convertToJavaScript(std::shared_ptr<CHTLJSBaseNode> node) const {
    if (!node) return "";
    
    switch (node->getNodeType()) {
        case CHTLJSNodeType::ENHANCED_SELECTOR:
            return processEnhancedSelector(node->getValue());
        case CHTLJSNodeType::VIRTUAL_OBJECT:
            return "const " + node->getName() + " = " + node->getValue();
        case CHTLJSNodeType::LISTEN_EXPRESSION:
            return processListenExpression(node);
        default:
            return node->getValue();
    }
}

std::string CHTLJSGenerator::convertToCHTLJS(std::shared_ptr<CHTLJSBaseNode> node) const {
    return node ? node->getValue() : "";
}

std::string CHTLJSGenerator::convertToHTML(std::shared_ptr<CHTLJSBaseNode> node) const {
    return node ? node->getValue() : "";
}

std::string CHTLJSGenerator::convertToCSS(std::shared_ptr<CHTLJSBaseNode> node) const {
    return node ? node->getValue() : "";
}

// 特殊语法处理实现
std::string CHTLJSGenerator::processEnhancedSelector(const std::string& selector) const {
    // 将{{选择器}}转换为document.querySelector('选择器')
    std::string result = selector;
    std::regex selectorRegex(R"(\{\{([^}]+)\}\})");
    result = std::regex_replace(result, selectorRegex, "document.querySelector('$1')");
    return result;
}

std::string CHTLJSGenerator::processVirtualObject(const std::string& name, std::shared_ptr<CHTLJSBaseNode> value) const {
    std::ostringstream oss;
    oss << "const " << name << " = ";
    
    if (value) {
        oss << generateExpression(value);
    } else {
        oss << "null";
    }
    
    return oss.str();
}

std::string CHTLJSGenerator::processListenExpression(std::shared_ptr<CHTLJSBaseNode> listen) const {
    std::ostringstream oss;
    oss << "{\n";
    
    auto children = listen->getChildren();
    for (const auto& child : children) {
        if (child) {
            std::string event = child->getAttribute("event");
            std::string handler = generateExpression(child->getChildren()[0]);
            oss << "  " << event << ": " << handler << ",\n";
        }
    }
    
    oss << "}";
    return oss.str();
}

// 其他未实现的方法
std::string CHTLJSGenerator::processDelegateExpression(std::shared_ptr<CHTLJSBaseNode> delegate) const { return ""; }
std::string CHTLJSGenerator::processAnimateExpression(std::shared_ptr<CHTLJSBaseNode> animate) const { return ""; }
std::string CHTLJSGenerator::processRouterExpression(std::shared_ptr<CHTLJSBaseNode> router) const { return ""; }
std::string CHTLJSGenerator::processFileloaderExpression(std::shared_ptr<CHTLJSBaseNode> fileloader) const { return ""; }
std::string CHTLJSGenerator::processUtilExpression(std::shared_ptr<CHTLJSBaseNode> util) const { return ""; }
std::string CHTLJSGenerator::processDeclarationSyntax(const std::string& keyword, std::shared_ptr<CHTLJSBaseNode> declaration) const { return ""; }
std::string CHTLJSGenerator::processKeyValuePairs(std::vector<std::shared_ptr<CHTLJSBaseNode>> pairs) const { return ""; }
std::string CHTLJSGenerator::processUnorderedPairs(std::vector<std::shared_ptr<CHTLJSBaseNode>> pairs) const { return ""; }
std::string CHTLJSGenerator::processOptionalPairs(std::vector<std::shared_ptr<CHTLJSBaseNode>> pairs) const { return ""; }
std::string CHTLJSGenerator::processChainExpression(std::vector<std::string> elements) const { return ""; }
std::string CHTLJSGenerator::processUnquotedLiteral(const std::string& literal) const { return literal; }
bool CHTLJSGenerator::isValidUnquotedLiteral(const std::string& literal) const { return true; }
std::string CHTLJSGenerator::processChainSyntax(const std::vector<std::string>& elements) const { return ""; }
std::string CHTLJSGenerator::processChainElement(const std::string& element) const { return element; }
void CHTLJSGenerator::reportError(const std::string& message, std::shared_ptr<CHTLJSBaseNode> node) { addError(message); }
void CHTLJSGenerator::reportWarning(const std::string& message, std::shared_ptr<CHTLJSBaseNode> node) { addWarning(message); }
std::string CHTLJSGenerator::formatError(const std::string& message, std::shared_ptr<CHTLJSBaseNode> node) const { return message; }
std::string CHTLJSGenerator::getNodeContext(std::shared_ptr<CHTLJSBaseNode> node) const { return ""; }
void CHTLJSGenerator::printNodeContext(std::shared_ptr<CHTLJSBaseNode> node) const {}
bool CHTLJSGenerator::validateJavaScript(const std::string& code) const { return true; }
bool CHTLJSGenerator::validateCHTLJS(const std::string& code) const { return true; }
bool CHTLJSGenerator::validateHTML(const std::string& code) const { return true; }
bool CHTLJSGenerator::validateCSS(const std::string& code) const { return true; }
void CHTLJSGenerator::updateStatistics(const std::string& feature) { featureUsage[feature]++; }
void CHTLJSGenerator::updateLineCount(const std::string& code) { generatedLines = std::count(code.begin(), code.end(), '\n'); }
void CHTLJSGenerator::updateCharacterCount(const std::string& code) { generatedCharacters = code.length(); }
std::string CHTLJSGenerator::formatIndent(int level) const { return std::string(level * 2, ' '); }
std::string CHTLJSGenerator::formatLine(const std::string& line) const { return line; }
std::string CHTLJSGenerator::formatBlock(const std::string& block) const { return block; }
std::string CHTLJSGenerator::formatExpression(const std::string& expression) const { return expression; }
std::string CHTLJSGenerator::formatStatement(const std::string& statement) const { return statement; }
std::string CHTLJSGenerator::formatDeclaration(const std::string& declaration) const { return declaration; }
std::string CHTLJSGenerator::removeWhitespace(const std::string& code) const { return code; }
std::string CHTLJSGenerator::removeComments(const std::string& code) const { return code; }
std::string CHTLJSGenerator::removeEmptyLines(const std::string& code) const { return code; }
std::string CHTLJSGenerator::compressIdentifiers(const std::string& code) const { return code; }
std::string CHTLJSGenerator::addIndentation(const std::string& code) const { return code; }
std::string CHTLJSGenerator::addLineBreaks(const std::string& code) const { return code; }
std::string CHTLJSGenerator::addSpacing(const std::string& code) const { return code; }
std::string CHTLJSGenerator::formatBrackets(const std::string& code) const { return code; }
std::string CHTLJSGenerator::formatOperators(const std::string& code) const { return code; }

} // namespace CHTL_JS