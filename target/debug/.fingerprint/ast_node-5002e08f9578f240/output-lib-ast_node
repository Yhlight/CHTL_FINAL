{"$message_type":"diagnostic","message":"no method named `with_generics` found for struct `syn::ItemImpl` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/ast_node_macro.rs","byte_start":536,"byte_end":958,"line_start":26,"line_end":39,"column_start":9,"column_end":14,"is_primary":false,"text":[{"text":"        Quote::new_call_site()","highlight_start":9,"highlight_end":31},{"text":"            .quote_with(smart_quote!(","highlight_start":1,"highlight_end":38},{"text":"                Vars {","highlight_start":1,"highlight_end":23},{"text":"                    Type: i.ident.clone(),","highlight_start":1,"highlight_end":43},{"text":"                    type_str: args.ty","highlight_start":1,"highlight_end":38},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    impl ::swc_common::AstNode for Type {","highlight_start":1,"highlight_end":58},{"text":"                        const TYPE: &'static str = type_str;","highlight_start":1,"highlight_end":61},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            ))","highlight_start":1,"highlight_end":15},{"text":"            .parse::<ItemImpl>()","highlight_start":1,"highlight_end":33},{"text":"            .with_generics(generics),","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/ast_node_macro.rs","byte_start":958,"byte_end":971,"line_start":39,"line_end":39,"column_start":14,"column_end":27,"is_primary":true,"text":[{"text":"            .with_generics(generics),","highlight_start":14,"highlight_end":27}],"label":"method not found in `ItemImpl`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `with_generics` found for struct `syn::ItemImpl` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/ast_node_macro.rs:39:14\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Quote::new_call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .quote_with(smart_quote!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Vars {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    Type: i.ident.clone(),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .parse::<ItemImpl>()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .with_generics(generics),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `ItemImpl`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`?` operator has incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":480,"byte_end":517,"line_start":20,"line_end":20,"column_start":19,"column_end":56,"is_primary":true,"text":[{"text":"            tags: content.parse_terminated(Lit::parse)?,","highlight_start":19,"highlight_end":56}],"label":"expected `Punctuated<Lit, ...>`, found `Punctuated<Lit, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`?` operator cannot convert from `syn::punctuated::Punctuated<syn::Lit, _>` to `swc_macros_common::prelude::Punctuated<syn::Lit, syn::token::Comma>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`Punctuated<Lit, _>` and `Punctuated<Lit, ...>` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`Punctuated<Lit, _>` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/punctuated.rs","byte_start":1571,"byte_end":1598,"line_start":47,"line_end":47,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Punctuated<T, P> {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`Punctuated<Lit, ...>` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/punctuated.rs","byte_start":1591,"byte_end":1618,"line_start":47,"line_end":47,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Punctuated<T, P> {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: `?` operator has incompatible types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:20:19\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            tags: content.parse_terminated(Lit::parse)?,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Punctuated<Lit, ...>`, found `Punctuated<Lit, _>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `?` operator cannot convert from `syn::punctuated::Punctuated<syn::Lit, _>` to `swc_macros_common::prelude::Punctuated<syn::Lit, syn::token::Comma>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `Punctuated<Lit, _>` and `Punctuated<Lit, ...>` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `Punctuated<Lit, _>` is defined in crate `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/punctuated.rs:47:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Punctuated<T, P> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `Punctuated<Lit, ...>` is defined in crate `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/punctuated.rs:47:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Punctuated<T, P> {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":1850,"byte_end":1854,"line_start":64,"line_end":64,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"                        if !is_attr_name(attr, \"tag\") {","highlight_start":42,"highlight_end":46}],"label":"expected `syn::attr::Attribute`, found `syn::Attribute`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":1837,"byte_end":1849,"line_start":64,"line_end":64,"column_start":29,"column_end":41,"is_primary":false,"text":[{"text":"                        if !is_attr_name(attr, \"tag\") {","highlight_start":29,"highlight_end":41}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::Attribute` and `syn::attr::Attribute` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::Attribute` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":880,"byte_end":917,"line_start":34,"line_end":34,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_struct!($($t)*));","highlight_start":9,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/attr.rs","byte_start":266,"byte_end":5692,"line_start":12,"line_end":156,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":1},{"text":"    /// An attribute like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`","highlight_start":1,"highlight_end":1},{"text":"    /// feature.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <br>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":1},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":1},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer doc comments like `/// # Example`.","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer block comments `/** # Example */`.","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner block comments `/*! Please file an issue */`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":1},{"text":"    /// is outer or inner. Doc comments and block comments are promoted to","highlight_start":1,"highlight_end":1},{"text":"    /// attributes, as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":1},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The `path` field gives the possibly colon-delimited path against which","highlight_start":1,"highlight_end":1},{"text":"    /// the attribute is resolved. It is equal to `\"doc\"` for desugared doc","highlight_start":1,"highlight_end":1},{"text":"    /// comments. The `tokens` field contains the rest of the attribute body as","highlight_start":1,"highlight_end":1},{"text":"    /// tokens.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// #[derive(Copy)]      #[crate::precondition x < 5]","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^^^~~~~~~         ^^^^^^^^^^^^^^^^^^^ ~~~~~","highlight_start":1,"highlight_end":1},{"text":"    ///   path  tokens                 path        tokens","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <br>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":1},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":1},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":1},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [`Parse`]: parse::Parse","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::parse`]: parse::ParseBuffer::parse","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::call`]: parse::ParseBuffer::call","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":1},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":1},{"text":"    /// //","highlight_start":1,"highlight_end":1},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":1},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":1},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":1},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":1},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":1},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":1},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":1},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///         })","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":1},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":1},{"text":"    /// attribute are held in an arbitrary `tokens: TokenStream`. Macros are","highlight_start":1,"highlight_end":1},{"text":"    /// expected to check the `path` of the attribute, decide whether they","highlight_start":1,"highlight_end":1},{"text":"    /// recognize it, and then parse the remaining tokens according to whatever","highlight_start":1,"highlight_end":1},{"text":"    /// grammar they wish to require for that kind of attribute.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// If the attribute you are parsing is expected to conform to the","highlight_start":1,"highlight_end":1},{"text":"    /// conventional structured form of attribute, use [`parse_meta()`] to","highlight_start":1,"highlight_end":1},{"text":"    /// obtain that structured representation. If the attribute follows some","highlight_start":1,"highlight_end":1},{"text":"    /// other grammar of its own, use [`parse_args()`] to parse that into the","highlight_start":1,"highlight_end":1},{"text":"    /// expected data structure.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [`parse_meta()`]: Attribute::parse_meta","highlight_start":1,"highlight_end":1},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":1},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":1},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":1},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":1},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":1},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":1},{"text":"    ///     /**","highlight_start":1,"highlight_end":1},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":1},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":1},{"text":"    ///      */","highlight_start":1,"highlight_end":1},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":1},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":1},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// };","highlight_start":1,"highlight_end":1},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":1},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":1},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":1},{"text":"    ///      \"]","highlight_start":1,"highlight_end":1},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":1},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":1},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// };","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":1},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":1},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":1},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":1},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":1},{"text":"        pub path: Path,","highlight_start":1,"highlight_end":1},{"text":"        pub tokens: TokenStream,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`syn::attr::Attribute` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1028,"byte_end":1052,"line_start":36,"line_end":36,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        $(#[$attr])* $pub $struct $name $body","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/attr.rs","byte_start":469,"byte_end":6261,"line_start":19,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":1},{"text":"    /// An attribute, like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <br>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":1},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":1},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer one-line doc comments like `/// Example`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner one-line doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Outer documentation blocks `/** Example */`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Inner documentation blocks `/*! Please file an issue */`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":1},{"text":"    /// is outer or inner.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// Every attribute has a `path` that indicates the intended interpretation","highlight_start":1,"highlight_end":1},{"text":"    /// of the rest of the attribute's contents. The path and the optional","highlight_start":1,"highlight_end":1},{"text":"    /// additional contents are represented together in the `meta` field of the","highlight_start":1,"highlight_end":1},{"text":"    /// attribute in three possible varieties:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Meta::Path &mdash; attributes whose information content conveys just a","highlight_start":1,"highlight_end":1},{"text":"    ///   path, for example the `#[test]` attribute.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Meta::List &mdash; attributes that carry arbitrary tokens after the","highlight_start":1,"highlight_end":1},{"text":"    ///   path, surrounded by a delimiter (parenthesis, bracket, or brace). For","highlight_start":1,"highlight_end":1},{"text":"    ///   example `#[derive(Copy)]` or `#[precondition(x < 5)]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// - Meta::NameValue &mdash; attributes with an `=` sign after the path,","highlight_start":1,"highlight_end":1},{"text":"    ///   followed by a Rust expression. For example `#[path =","highlight_start":1,"highlight_end":1},{"text":"    ///   \"sys/windows.rs\"]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// All doc comments are represented in the NameValue style with a path of","highlight_start":1,"highlight_end":1},{"text":"    /// \"doc\", as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":1},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```text","highlight_start":1,"highlight_end":1},{"text":"    /// #[derive(Copy, Clone)]","highlight_start":1,"highlight_end":1},{"text":"    ///   ~~~~~~Path","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^Meta::List","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// #[path = \"sys/windows.rs\"]","highlight_start":1,"highlight_end":1},{"text":"    ///   ~~~~Path","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^^^^^Meta::NameValue","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// #[test]","highlight_start":1,"highlight_end":1},{"text":"    ///   ^^^^Meta::Path","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <br>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":1},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":1},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":1},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [`Parse`]: crate::parse::Parse","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::parse`]: crate::parse::ParseBuffer::parse","highlight_start":1,"highlight_end":1},{"text":"    /// [`ParseStream::call`]: crate::parse::ParseBuffer::call","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":1},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":1},{"text":"    /// //","highlight_start":1,"highlight_end":1},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":1},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":1},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":1},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":1},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":1},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":1},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":1},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":1},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":1},{"text":"    ///         })","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// }","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":1},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":1},{"text":"    /// `Meta::List` variety of attribute are held in an arbitrary `tokens:","highlight_start":1,"highlight_end":1},{"text":"    /// TokenStream`. Macros are expected to check the `path` of the attribute,","highlight_start":1,"highlight_end":1},{"text":"    /// decide whether they recognize it, and then parse the remaining tokens","highlight_start":1,"highlight_end":1},{"text":"    /// according to whatever grammar they wish to require for that kind of","highlight_start":1,"highlight_end":1},{"text":"    /// attribute. Use [`parse_args()`] to parse those tokens into the expected","highlight_start":1,"highlight_end":1},{"text":"    /// data structure.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":1},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":1},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":1},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":1},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":1},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":1},{"text":"    ///     /**","highlight_start":1,"highlight_end":1},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":1},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":1},{"text":"    ///      */","highlight_start":1,"highlight_end":1},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":1},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":1},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// };","highlight_start":1,"highlight_end":1},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":1},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":1},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":1},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":1},{"text":"    ///      \"]","highlight_start":1,"highlight_end":1},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":1},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":1},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":1},{"text":"    ///     }","highlight_start":1,"highlight_end":1},{"text":"    /// };","highlight_start":1,"highlight_end":1},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":1},{"text":"    /// ```","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":1},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":1},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":1},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":1},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":1},{"text":"        pub meta: Meta,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":728,"byte_end":740,"line_start":35,"line_end":35,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"pub fn is_attr_name(attr: &Attribute, name: &str) -> bool {","highlight_start":8,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:64:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if !is_attr_name(attr, \"tag\") {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `syn::attr::Attribute`, found `syn::Attribute`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::Attribute` and `syn::attr::Attribute` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::Attribute` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/attr.rs:12:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// *This type is available only if Syn is built with the `\"deriv\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::attr::Attribute` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/attr.rs:19:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute, like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// <br>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:35:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn is_attr_name(attr: &Attribute, name: &str) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `strip_attrs_pub` which comes from the expansion of the macro `ast_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":4530,"byte_end":4534,"line_start":136,"line_end":136,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"                        if !is_attr_name(attr, \"tag\") {","highlight_start":42,"highlight_end":46}],"label":"expected `syn::attr::Attribute`, found `syn::Attribute`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":4517,"byte_end":4529,"line_start":136,"line_end":136,"column_start":29,"column_end":41,"is_primary":false,"text":[{"text":"                        if !is_attr_name(attr, \"tag\") {","highlight_start":29,"highlight_end":41}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::Attribute` and `syn::attr::Attribute` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::Attribute` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":880,"byte_end":917,"line_start":34,"line_end":34,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_struct!($($t)*));","highlight_start":9,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/attr.rs","byte_start":266,"byte_end":5692,"line_start":12,"line_end":156,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":14},{"text":"    /// An attribute like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`","highlight_start":1,"highlight_end":85},{"text":"    /// feature.*","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":80},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":46},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":79},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":55},{"text":"    /// - Outer doc comments like `/// # Example`.","highlight_start":1,"highlight_end":51},{"text":"    /// - Inner doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":62},{"text":"    /// - Outer block comments `/** # Example */`.","highlight_start":1,"highlight_end":51},{"text":"    /// - Inner block comments `/*! Please file an issue */`.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":81},{"text":"    /// is outer or inner. Doc comments and block comments are promoted to","highlight_start":1,"highlight_end":75},{"text":"    /// attributes, as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":77},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `path` field gives the possibly colon-delimited path against which","highlight_start":1,"highlight_end":79},{"text":"    /// the attribute is resolved. It is equal to `\"doc\"` for desugared doc","highlight_start":1,"highlight_end":76},{"text":"    /// comments. The `tokens` field contains the rest of the attribute body as","highlight_start":1,"highlight_end":80},{"text":"    /// tokens.","highlight_start":1,"highlight_end":16},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// #[derive(Copy)]      #[crate::precondition x < 5]","highlight_start":1,"highlight_end":58},{"text":"    ///   ^^^^^^~~~~~~         ^^^^^^^^^^^^^^^^^^^ ~~~~~","highlight_start":1,"highlight_end":57},{"text":"    ///   path  tokens                 path        tokens","highlight_start":1,"highlight_end":58},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":76},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":63},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":67},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":78},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Parse`]: parse::Parse","highlight_start":1,"highlight_end":32},{"text":"    /// [`ParseStream::parse`]: parse::ParseBuffer::parse","highlight_start":1,"highlight_end":58},{"text":"    /// [`ParseStream::call`]: parse::ParseBuffer::call","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":52},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":49},{"text":"    /// //","highlight_start":1,"highlight_end":11},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":34},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":25},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":28},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":35},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":42},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":25},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":35},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":36},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":59},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":32},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":64},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":50},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":42},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":48},{"text":"    ///         })","highlight_start":1,"highlight_end":19},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":76},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":80},{"text":"    /// attribute are held in an arbitrary `tokens: TokenStream`. Macros are","highlight_start":1,"highlight_end":77},{"text":"    /// expected to check the `path` of the attribute, decide whether they","highlight_start":1,"highlight_end":75},{"text":"    /// recognize it, and then parse the remaining tokens according to whatever","highlight_start":1,"highlight_end":80},{"text":"    /// grammar they wish to require for that kind of attribute.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If the attribute you are parsing is expected to conform to the","highlight_start":1,"highlight_end":71},{"text":"    /// conventional structured form of attribute, use [`parse_meta()`] to","highlight_start":1,"highlight_end":75},{"text":"    /// obtain that structured representation. If the attribute follows some","highlight_start":1,"highlight_end":77},{"text":"    /// other grammar of its own, use [`parse_args()`] to parse that into the","highlight_start":1,"highlight_end":78},{"text":"    /// expected data structure.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`parse_meta()`]: Attribute::parse_meta","highlight_start":1,"highlight_end":48},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":23},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":77},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":81},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":43},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":42},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":41},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":34},{"text":"    ///     /**","highlight_start":1,"highlight_end":16},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      */","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":53},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":48},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":50},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":23},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      \"]","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":63},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":56},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":78},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":27},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":36},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":30},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":43},{"text":"        pub path: Path,","highlight_start":1,"highlight_end":24},{"text":"        pub tokens: TokenStream,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`syn::attr::Attribute` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1028,"byte_end":1052,"line_start":36,"line_end":36,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        $(#[$attr])* $pub $struct $name $body","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/attr.rs","byte_start":469,"byte_end":6261,"line_start":19,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":14},{"text":"    /// An attribute, like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":80},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":79},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer one-line doc comments like `/// Example`.","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Inner one-line doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer documentation blocks `/** Example */`.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Inner documentation blocks `/*! Please file an issue */`.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":81},{"text":"    /// is outer or inner.","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every attribute has a `path` that indicates the intended interpretation","highlight_start":1,"highlight_end":80},{"text":"    /// of the rest of the attribute's contents. The path and the optional","highlight_start":1,"highlight_end":75},{"text":"    /// additional contents are represented together in the `meta` field of the","highlight_start":1,"highlight_end":80},{"text":"    /// attribute in three possible varieties:","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Meta::Path &mdash; attributes whose information content conveys just a","highlight_start":1,"highlight_end":81},{"text":"    ///   path, for example the `#[test]` attribute.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Meta::List &mdash; attributes that carry arbitrary tokens after the","highlight_start":1,"highlight_end":78},{"text":"    ///   path, surrounded by a delimiter (parenthesis, bracket, or brace). For","highlight_start":1,"highlight_end":80},{"text":"    ///   example `#[derive(Copy)]` or `#[precondition(x < 5)]`.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Meta::NameValue &mdash; attributes with an `=` sign after the path,","highlight_start":1,"highlight_end":78},{"text":"    ///   followed by a Rust expression. For example `#[path =","highlight_start":1,"highlight_end":63},{"text":"    ///   \"sys/windows.rs\"]`.","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// All doc comments are represented in the NameValue style with a path of","highlight_start":1,"highlight_end":79},{"text":"    /// \"doc\", as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":72},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// #[derive(Copy, Clone)]","highlight_start":1,"highlight_end":31},{"text":"    ///   ~~~~~~Path","highlight_start":1,"highlight_end":21},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^Meta::List","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// #[path = \"sys/windows.rs\"]","highlight_start":1,"highlight_end":35},{"text":"    ///   ~~~~Path","highlight_start":1,"highlight_end":19},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^^^^^Meta::NameValue","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// #[test]","highlight_start":1,"highlight_end":16},{"text":"    ///   ^^^^Meta::Path","highlight_start":1,"highlight_end":25},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":76},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":63},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":67},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":78},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Parse`]: crate::parse::Parse","highlight_start":1,"highlight_end":39},{"text":"    /// [`ParseStream::parse`]: crate::parse::ParseBuffer::parse","highlight_start":1,"highlight_end":65},{"text":"    /// [`ParseStream::call`]: crate::parse::ParseBuffer::call","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":52},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":49},{"text":"    /// //","highlight_start":1,"highlight_end":11},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":34},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":25},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":28},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":35},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":42},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":25},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":35},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":36},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":59},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":32},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":64},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":50},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":42},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":48},{"text":"    ///         })","highlight_start":1,"highlight_end":19},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":76},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":80},{"text":"    /// `Meta::List` variety of attribute are held in an arbitrary `tokens:","highlight_start":1,"highlight_end":76},{"text":"    /// TokenStream`. Macros are expected to check the `path` of the attribute,","highlight_start":1,"highlight_end":80},{"text":"    /// decide whether they recognize it, and then parse the remaining tokens","highlight_start":1,"highlight_end":78},{"text":"    /// according to whatever grammar they wish to require for that kind of","highlight_start":1,"highlight_end":76},{"text":"    /// attribute. Use [`parse_args()`] to parse those tokens into the expected","highlight_start":1,"highlight_end":80},{"text":"    /// data structure.","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":23},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":77},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":81},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":43},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":42},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":41},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":34},{"text":"    ///     /**","highlight_start":1,"highlight_end":16},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      */","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":53},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":48},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":50},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":23},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      \"]","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":63},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":56},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":77},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":27},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":36},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":30},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":43},{"text":"        pub meta: Meta,","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":728,"byte_end":740,"line_start":35,"line_end":35,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"pub fn is_attr_name(attr: &Attribute, name: &str) -> bool {","highlight_start":8,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:136:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m136\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                        if !is_attr_name(attr, \"tag\") {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `syn::attr::Attribute`, found `syn::Attribute`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::Attribute` and `syn::attr::Attribute` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::Attribute` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/attr.rs:12:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// *This type is available only if Syn is built with the `\"deriv\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::attr::Attribute` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/attr.rs:19:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute, like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// <br>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:35:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn is_attr_name(attr: &Attribute, name: &str) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `strip_attrs_pub` which comes from the expansion of the macro `ast_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":8047,"byte_end":8056,"line_start":212,"line_end":212,"column_start":44,"column_end":53,"is_primary":true,"text":[{"text":"                                    cases: str_cases,","highlight_start":44,"highlight_end":53}],"label":"expected `Punctuated<Pat, Or>`, found `Punctuated<Pat, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Punctuated<Pat, _>` and `Punctuated<Pat, Or>` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`Punctuated<Pat, _>` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/punctuated.rs","byte_start":1591,"byte_end":1618,"line_start":47,"line_end":47,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Punctuated<T, P> {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`Punctuated<Pat, Or>` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/punctuated.rs","byte_start":1571,"byte_end":1598,"line_start":47,"line_end":47,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Punctuated<T, P> {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:212:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m212\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   cases: str_cases,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Punctuated<Pat, Or>`, found `Punctuated<Pat, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `Punctuated<Pat, _>` and `Punctuated<Pat, Or>` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `Punctuated<Pat, _>` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/punctuated.rs:47:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Punctuated<T, P> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `Punctuated<Pat, Or>` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/punctuated.rs:47:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Punctuated<T, P> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":8318,"byte_end":8329,"line_start":217,"line_end":217,"column_start":44,"column_end":55,"is_primary":true,"text":[{"text":"                                    cases: bytes_cases,","highlight_start":44,"highlight_end":55}],"label":"expected `Punctuated<Pat, Or>`, found `Punctuated<Pat, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`Punctuated<Pat, _>` and `Punctuated<Pat, Or>` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`Punctuated<Pat, _>` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/punctuated.rs","byte_start":1591,"byte_end":1618,"line_start":47,"line_end":47,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Punctuated<T, P> {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"`Punctuated<Pat, Or>` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/punctuated.rs","byte_start":1571,"byte_end":1598,"line_start":47,"line_end":47,"column_start":1,"column_end":28,"is_primary":true,"text":[{"text":"pub struct Punctuated<T, P> {","highlight_start":1,"highlight_end":28}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:217:44\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m217\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m                   cases: bytes_cases,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Punctuated<Pat, Or>`, found `Punctuated<Pat, _>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `Punctuated<Pat, _>` and `Punctuated<Pat, Or>` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `Punctuated<Pat, _>` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/punctuated.rs:47:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Punctuated<T, P> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `Punctuated<Pat, Or>` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/punctuated.rs:47:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct Punctuated<T, P> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11337,"byte_end":11348,"line_start":293,"line_end":293,"column_start":30,"column_end":41,"is_primary":true,"text":[{"text":"                match_token: call_site(),","highlight_start":30,"highlight_end":41}],"label":"expected `Match`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Match`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11337,"byte_end":11337,"line_start":293,"line_end":293,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"                match_token: call_site(),","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"syn::token::Match { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11348,"byte_end":11348,"line_start":293,"line_end":293,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                match_token: call_site(),","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:293:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                match_token: call_site(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Match`, found `Span`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Match`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m293\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                match_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Match { span: \u001b[0m\u001b[0mcall_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11424,"byte_end":11435,"line_start":295,"line_end":295,"column_start":30,"column_end":41,"is_primary":true,"text":[{"text":"                brace_token: call_site(),","highlight_start":30,"highlight_end":41}],"label":"expected `Brace`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Brace`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11424,"byte_end":11424,"line_start":295,"line_end":295,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"                brace_token: call_site(),","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"syn::token::Brace { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11435,"byte_end":11435,"line_start":295,"line_end":295,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                brace_token: call_site(),","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:295:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                brace_token: call_site(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Brace`, found `Span`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Brace`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m295\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                brace_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Brace { span: \u001b[0m\u001b[0mcall_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11622,"byte_end":11633,"line_start":300,"line_end":300,"column_start":30,"column_end":41,"is_primary":true,"text":[{"text":"                match_token: call_site(),","highlight_start":30,"highlight_end":41}],"label":"expected `Match`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Match`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11622,"byte_end":11622,"line_start":300,"line_end":300,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"                match_token: call_site(),","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"syn::token::Match { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11633,"byte_end":11633,"line_start":300,"line_end":300,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                match_token: call_site(),","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:300:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                match_token: call_site(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Match`, found `Span`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Match`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m300\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                match_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Match { span: \u001b[0m\u001b[0mcall_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11709,"byte_end":11720,"line_start":302,"line_end":302,"column_start":30,"column_end":41,"is_primary":true,"text":[{"text":"                brace_token: call_site(),","highlight_start":30,"highlight_end":41}],"label":"expected `Brace`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Brace`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11709,"byte_end":11709,"line_start":302,"line_end":302,"column_start":30,"column_end":30,"is_primary":true,"text":[{"text":"                brace_token: call_site(),","highlight_start":30,"highlight_end":30}],"label":null,"suggested_replacement":"syn::token::Brace { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":11720,"byte_end":11720,"line_start":302,"line_end":302,"column_start":41,"column_end":41,"is_primary":true,"text":[{"text":"                brace_token: call_site(),","highlight_start":41,"highlight_end":41}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:302:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                brace_token: call_site(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Brace`, found `Span`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Brace`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m302\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                brace_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Brace { span: \u001b[0m\u001b[0mcall_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15190,"byte_end":15201,"line_start":388,"line_end":388,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"            match_token: call_site(),","highlight_start":26,"highlight_end":37}],"label":"expected `Match`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Match`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15190,"byte_end":15190,"line_start":388,"line_end":388,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            match_token: call_site(),","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"syn::token::Match { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15201,"byte_end":15201,"line_start":388,"line_end":388,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"            match_token: call_site(),","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:388:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            match_token: call_site(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Match`, found `Span`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Match`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m388\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            match_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Match { span: \u001b[0m\u001b[0mcall_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15272,"byte_end":15283,"line_start":390,"line_end":390,"column_start":26,"column_end":37,"is_primary":true,"text":[{"text":"            brace_token: call_site(),","highlight_start":26,"highlight_end":37}],"label":"expected `Brace`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Brace`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15272,"byte_end":15272,"line_start":390,"line_end":390,"column_start":26,"column_end":26,"is_primary":true,"text":[{"text":"            brace_token: call_site(),","highlight_start":26,"highlight_end":26}],"label":null,"suggested_replacement":"syn::token::Brace { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15283,"byte_end":15283,"line_start":390,"line_end":390,"column_start":37,"column_end":37,"is_primary":true,"text":[{"text":"            brace_token: call_site(),","highlight_start":37,"highlight_end":37}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:390:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m390\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            brace_token: call_site(),\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Brace`, found `Span`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Brace`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m390\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            brace_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Brace { span: \u001b[0m\u001b[0mcall_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `with_generics` found for struct `syn::ItemImpl` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":15690,"byte_end":16885,"line_start":405,"line_end":438,"column_start":9,"column_end":14,"is_primary":false,"text":[{"text":"        Quote::new_call_site()","highlight_start":9,"highlight_end":31},{"text":"            .quote_with(smart_quote!(","highlight_start":1,"highlight_end":38},{"text":"                Vars {","highlight_start":1,"highlight_end":23},{"text":"                    match_type_expr,","highlight_start":1,"highlight_end":37},{"text":"                    Enum: &ident,","highlight_start":1,"highlight_end":34},{"text":"                    tag_expr,","highlight_start":1,"highlight_end":30},{"text":"                    variants","highlight_start":1,"highlight_end":29},{"text":"                },","highlight_start":1,"highlight_end":19},{"text":"                {","highlight_start":1,"highlight_end":18},{"text":"                    impl<'de> serde::Deserialize<'de> for Enum {","highlight_start":1,"highlight_end":65},{"text":"                        #[allow(unreachable_code)]","highlight_start":1,"highlight_end":51},{"text":"                        fn deserialize<__D>(","highlight_start":1,"highlight_end":45},{"text":"                            __deserializer: __D,","highlight_start":1,"highlight_end":49},{"text":"                        ) -> ::std::result::Result<Self, __D::Error>","highlight_start":1,"highlight_end":69},{"text":"                        where","highlight_start":1,"highlight_end":30},{"text":"                            __D: serde::Deserializer<'de>,","highlight_start":1,"highlight_end":59},{"text":"                        {","highlight_start":1,"highlight_end":26},{"text":"                            enum __TypeVariant {","highlight_start":1,"highlight_end":49},{"text":"                                variants,","highlight_start":1,"highlight_end":42},{"text":"                            }","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let __content = <swc_common::private::serde::de::Content as serde::Deserialize>::deserialize(","highlight_start":1,"highlight_end":122},{"text":"                                __deserializer,","highlight_start":1,"highlight_end":48},{"text":"                            )?;","highlight_start":1,"highlight_end":32},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            let __tagged = tag_expr;","highlight_start":1,"highlight_end":53},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                            match_type_expr","highlight_start":1,"highlight_end":44},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            ))","highlight_start":1,"highlight_end":15},{"text":"            .parse::<ItemImpl>()","highlight_start":1,"highlight_end":33},{"text":"            .with_generics(generics)","highlight_start":1,"highlight_end":14}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs","byte_start":16885,"byte_end":16898,"line_start":438,"line_end":438,"column_start":14,"column_end":27,"is_primary":true,"text":[{"text":"            .with_generics(generics)","highlight_start":14,"highlight_end":27}],"label":"method not found in `ItemImpl`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `with_generics` found for struct `syn::ItemImpl` in the current scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/enum_deserialize.rs:438:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m405\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Quote::new_call_site()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m406\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .quote_with(smart_quote!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m407\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Vars {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m408\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    match_type_expr,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m437\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .parse::<ItemImpl>()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m438\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            .with_generics(generics)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `ItemImpl`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_____________|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":529,"byte_end":535,"line_start":25,"line_end":25,"column_start":33,"column_end":39,"is_primary":true,"text":[{"text":"    let arms = Binder::new_from(&input)","highlight_start":33,"highlight_end":39}],"label":"expected `DeriveInput`, found `syn::DeriveInput`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":512,"byte_end":528,"line_start":25,"line_end":25,"column_start":16,"column_end":32,"is_primary":false,"text":[{"text":"    let arms = Binder::new_from(&input)","highlight_start":16,"highlight_end":32}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::DeriveInput` and `DeriveInput` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::DeriveInput` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":880,"byte_end":917,"line_start":34,"line_end":34,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_struct!($($t)*));","highlight_start":9,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/derive.rs","byte_start":50,"byte_end":703,"line_start":4,"line_end":25,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":1},{"text":"    /// Data structure sent to a `proc_macro_derive` macro.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *This type is available only if Syn is built with the `\"derive\"` feature.*","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(feature = \"derive\")))]","highlight_start":1,"highlight_end":1},{"text":"    pub struct DeriveInput {","highlight_start":1,"highlight_end":1},{"text":"        /// Attributes tagged on the whole struct or enum.","highlight_start":1,"highlight_end":1},{"text":"        pub attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Visibility of the struct or enum.","highlight_start":1,"highlight_end":1},{"text":"        pub vis: Visibility,","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Name of the struct or enum.","highlight_start":1,"highlight_end":1},{"text":"        pub ident: Ident,","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Generics required to complete the definition.","highlight_start":1,"highlight_end":1},{"text":"        pub generics: Generics,","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Data within the struct or enum.","highlight_start":1,"highlight_end":1},{"text":"        pub data: Data,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`DeriveInput` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1028,"byte_end":1052,"line_start":36,"line_end":36,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        $(#[$attr])* $pub $struct $name $body","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/derive.rs","byte_start":223,"byte_end":533,"line_start":9,"line_end":19,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":1},{"text":"    /// Data structure sent to a `proc_macro_derive` macro.","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"derive\")))]","highlight_start":1,"highlight_end":1},{"text":"    pub struct DeriveInput {","highlight_start":1,"highlight_end":1},{"text":"        pub attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":1},{"text":"        pub vis: Visibility,","highlight_start":1,"highlight_end":1},{"text":"        pub ident: Ident,","highlight_start":1,"highlight_end":1},{"text":"        pub generics: Generics,","highlight_start":1,"highlight_end":1},{"text":"        pub data: Data,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/binder.rs","byte_start":1122,"byte_end":1130,"line_start":60,"line_end":60,"column_start":12,"column_end":20,"is_primary":true,"text":[{"text":"    pub fn new_from(input: &'a DeriveInput) -> Self {","highlight_start":12,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:25:33\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let arms = Binder::new_from(&input)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `DeriveInput`, found `syn::DeriveInput`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::DeriveInput` and `DeriveInput` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::DeriveInput` is defined in crate `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/derive.rs:4:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m4\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Data structure sent to a `proc_macro_derive` macro.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// *This type is available only if Syn is built with the `\"derive\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `DeriveInput` is defined in crate `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/derive.rs:9:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Data structure sent to a `proc_macro_derive` macro.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[cfg_attr(docsrs, doc(cfg(feature = \"derive\")))]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct DeriveInput {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/binder.rs:60:12\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m60\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub fn new_from(input: &'a DeriveInput) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `strip_attrs_pub` which comes from the expansion of the macro `ast_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":648,"byte_end":658,"line_start":29,"line_end":29,"column_start":52,"column_end":62,"is_primary":true,"text":[{"text":"            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);","highlight_start":52,"highlight_end":62}],"label":"expected `Ref`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":643,"byte_end":647,"line_start":29,"line_end":29,"column_start":47,"column_end":51,"is_primary":false,"text":[{"text":"            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);","highlight_start":47,"highlight_end":51}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `proc_macro2::Span` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":648,"byte_end":658,"line_start":29,"line_end":29,"column_start":52,"column_end":62,"is_primary":false,"text":[{"text":"            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);","highlight_start":52,"highlight_end":62}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":643,"byte_end":659,"line_start":29,"line_end":29,"column_start":47,"column_end":63,"is_primary":true,"text":[{"text":"            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);","highlight_start":47,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/option.rs","byte_start":22706,"byte_end":22710,"line_start":579,"line_end":579,"column_start":5,"column_end":9,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"try wrapping the expression in `syn::token::Ref`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":648,"byte_end":648,"line_start":29,"line_end":29,"column_start":52,"column_end":52,"is_primary":true,"text":[{"text":"            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);","highlight_start":52,"highlight_end":52}],"label":null,"suggested_replacement":"syn::token::Ref { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":658,"byte_end":658,"line_start":29,"line_end":29,"column_start":62,"column_end":62,"is_primary":true,"text":[{"text":"            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);","highlight_start":62,"highlight_end":62}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:29:52\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Ref`, found `Span`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this enum variant are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the type constructed contains `proc_macro2::Span` due to the type of the argument passed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:29:47\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            let (pat, bindings) = v.bind(\"_\", Some(def_site()), None);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis argument influences the type of `Some`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/option.rs:579:5\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Ref`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            let (pat, bindings) = v.bind(\"_\", Some(\u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Ref { span: \u001b[0m\u001b[0mdef_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m), None);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                    \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":992,"byte_end":995,"line_start":41,"line_end":41,"column_start":17,"column_end":20,"is_primary":true,"text":[{"text":"                pat,","highlight_start":17,"highlight_end":20}],"label":"expected `syn::Pat`, found `syn::pat::Pat`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::pat::Pat` and `syn::Pat` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::pat::Pat` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1631,"byte_end":1653,"line_start":61,"line_end":61,"column_start":27,"column_end":49,"is_primary":true,"text":[{"text":"        $(#[$enum_attr])* $pub $enum $name $body","highlight_start":27,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/pat.rs","byte_start":359,"byte_end":3228,"line_start":15,"line_end":102,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_enum_of_structs! {","highlight_start":1,"highlight_end":1},{"text":"    /// A pattern in a local binding, function signature, match expression, or","highlight_start":1,"highlight_end":1},{"text":"    /// various other places.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax tree enum","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type is a [syntax tree enum].","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [syntax tree enum]: crate::expr::Expr#syntax-tree-enums","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(feature = \"full\")))]","highlight_start":1,"highlight_end":1},{"text":"    #[non_exhaustive]","highlight_start":1,"highlight_end":1},{"text":"    pub enum Pat {","highlight_start":1,"highlight_end":1},{"text":"        /// A const block: `const { ... }`.","highlight_start":1,"highlight_end":1},{"text":"        Const(PatConst),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.","highlight_start":1,"highlight_end":1},{"text":"        Ident(PatIdent),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A literal pattern: `0`.","highlight_start":1,"highlight_end":1},{"text":"        Lit(PatLit),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A macro in pattern position.","highlight_start":1,"highlight_end":1},{"text":"        Macro(PatMacro),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A pattern that matches any one of a set of cases.","highlight_start":1,"highlight_end":1},{"text":"        Or(PatOr),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A parenthesized pattern: `(A | B)`.","highlight_start":1,"highlight_end":1},{"text":"        Paren(PatParen),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A path pattern like `Color::Red`, optionally qualified with a","highlight_start":1,"highlight_end":1},{"text":"        /// self-type.","highlight_start":1,"highlight_end":1},{"text":"        ///","highlight_start":1,"highlight_end":1},{"text":"        /// Unqualified path patterns can legally refer to variants, structs,","highlight_start":1,"highlight_end":1},{"text":"        /// constants or associated constants. Qualified path patterns like","highlight_start":1,"highlight_end":1},{"text":"        /// `<A>::B::C` and `<A as Trait>::B::C` can only legally refer to","highlight_start":1,"highlight_end":1},{"text":"        /// associated constants.","highlight_start":1,"highlight_end":1},{"text":"        Path(PatPath),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A range pattern: `1..=2`.","highlight_start":1,"highlight_end":1},{"text":"        Range(PatRange),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A reference pattern: `&mut var`.","highlight_start":1,"highlight_end":1},{"text":"        Reference(PatReference),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// The dots in a tuple or slice pattern: `[0, 1, ..]`.","highlight_start":1,"highlight_end":1},{"text":"        Rest(PatRest),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.","highlight_start":1,"highlight_end":1},{"text":"        Slice(PatSlice),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A struct or struct variant pattern: `Variant { x, y, .. }`.","highlight_start":1,"highlight_end":1},{"text":"        Struct(PatStruct),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A tuple pattern: `(a, b)`.","highlight_start":1,"highlight_end":1},{"text":"        Tuple(PatTuple),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.","highlight_start":1,"highlight_end":1},{"text":"        TupleStruct(PatTupleStruct),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A type ascription pattern: `foo: f64`.","highlight_start":1,"highlight_end":1},{"text":"        Type(PatType),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Tokens in pattern position not interpreted by Syn.","highlight_start":1,"highlight_end":1},{"text":"        Verbatim(TokenStream),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A pattern that matches any value: `_`.","highlight_start":1,"highlight_end":1},{"text":"        Wild(PatWild),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // For testing exhaustiveness in downstream code, use the following idiom:","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        //     match pat {","highlight_start":1,"highlight_end":1},{"text":"        //         #![cfg_attr(test, deny(non_exhaustive_omitted_patterns))]","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        //         Pat::Box(pat) => {...}","highlight_start":1,"highlight_end":1},{"text":"        //         Pat::Ident(pat) => {...}","highlight_start":1,"highlight_end":1},{"text":"        //         ...","highlight_start":1,"highlight_end":1},{"text":"        //         Pat::Wild(pat) => {...}","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        //         _ => { /* some sane fallback */ }","highlight_start":1,"highlight_end":1},{"text":"        //     }","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        // This way we fail your tests but don't break your library when adding","highlight_start":1,"highlight_end":1},{"text":"        // a variant. You will be notified by a test failure when a variant is","highlight_start":1,"highlight_end":1},{"text":"        // added, so that you can add code to handle it, but your library will","highlight_start":1,"highlight_end":1},{"text":"        // continue to compile and work for downstream users in the interim.","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_enum_of_structs!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1383,"byte_end":1415,"line_start":53,"line_end":53,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"macro_rules! ast_enum_of_structs {","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`syn::Pat` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":1327,"byte_end":1362,"line_start":55,"line_end":55,"column_start":9,"column_end":44,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_enum!($($t)*));","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":1543,"byte_end":1594,"line_start":65,"line_end":65,"column_start":9,"column_end":60,"is_primary":false,"text":[{"text":"        ast_enum!($(#[$enum_attr])* $pub $enum $name $body);","highlight_start":9,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/pat.rs","byte_start":80,"byte_end":3228,"line_start":5,"line_end":98,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_enum_of_structs! {","highlight_start":1,"highlight_end":1},{"text":"    /// A pattern in a local binding, function signature, match expression, or","highlight_start":1,"highlight_end":1},{"text":"    /// various other places.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *This type is available only if Syn is built with the `\"full\"` feature.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax tree enum","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type is a [syntax tree enum].","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [syntax tree enum]: Expr#syntax-tree-enums","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(feature = \"full\")))]","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(not(syn_no_non_exhaustive), non_exhaustive)]","highlight_start":1,"highlight_end":1},{"text":"    pub enum Pat {","highlight_start":1,"highlight_end":1},{"text":"        /// A box pattern: `box v`.","highlight_start":1,"highlight_end":1},{"text":"        Box(PatBox),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.","highlight_start":1,"highlight_end":1},{"text":"        Ident(PatIdent),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A literal pattern: `0`.","highlight_start":1,"highlight_end":1},{"text":"        ///","highlight_start":1,"highlight_end":1},{"text":"        /// This holds an `Expr` rather than a `Lit` because negative numbers","highlight_start":1,"highlight_end":1},{"text":"        /// are represented as an `Expr::Unary`.","highlight_start":1,"highlight_end":1},{"text":"        Lit(PatLit),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A macro in pattern position.","highlight_start":1,"highlight_end":1},{"text":"        Macro(PatMacro),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A pattern that matches any one of a set of cases.","highlight_start":1,"highlight_end":1},{"text":"        Or(PatOr),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A path pattern like `Color::Red`, optionally qualified with a","highlight_start":1,"highlight_end":1},{"text":"        /// self-type.","highlight_start":1,"highlight_end":1},{"text":"        ///","highlight_start":1,"highlight_end":1},{"text":"        /// Unqualified path patterns can legally refer to variants, structs,","highlight_start":1,"highlight_end":1},{"text":"        /// constants or associated constants. Qualified path patterns like","highlight_start":1,"highlight_end":1},{"text":"        /// `<A>::B::C` and `<A as Trait>::B::C` can only legally refer to","highlight_start":1,"highlight_end":1},{"text":"        /// associated constants.","highlight_start":1,"highlight_end":1},{"text":"        Path(PatPath),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A range pattern: `1..=2`.","highlight_start":1,"highlight_end":1},{"text":"        Range(PatRange),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A reference pattern: `&mut var`.","highlight_start":1,"highlight_end":1},{"text":"        Reference(PatReference),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// The dots in a tuple or slice pattern: `[0, 1, ..]`","highlight_start":1,"highlight_end":1},{"text":"        Rest(PatRest),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.","highlight_start":1,"highlight_end":1},{"text":"        Slice(PatSlice),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A struct or struct variant pattern: `Variant { x, y, .. }`.","highlight_start":1,"highlight_end":1},{"text":"        Struct(PatStruct),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A tuple pattern: `(a, b)`.","highlight_start":1,"highlight_end":1},{"text":"        Tuple(PatTuple),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.","highlight_start":1,"highlight_end":1},{"text":"        TupleStruct(PatTupleStruct),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A type ascription pattern: `foo: f64`.","highlight_start":1,"highlight_end":1},{"text":"        Type(PatType),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Tokens in pattern position not interpreted by Syn.","highlight_start":1,"highlight_end":1},{"text":"        Verbatim(TokenStream),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// A pattern that matches any value: `_`.","highlight_start":1,"highlight_end":1},{"text":"        Wild(PatWild),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        // Not public API.","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        // For testing exhaustiveness in downstream code, use the following idiom:","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        //     match pat {","highlight_start":1,"highlight_end":1},{"text":"        //         Pat::Box(pat) => {...}","highlight_start":1,"highlight_end":1},{"text":"        //         Pat::Ident(pat) => {...}","highlight_start":1,"highlight_end":1},{"text":"        //         ...","highlight_start":1,"highlight_end":1},{"text":"        //         Pat::Wild(pat) => {...}","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        //         #[cfg_attr(test, deny(non_exhaustive_omitted_patterns))]","highlight_start":1,"highlight_end":1},{"text":"        //         _ => { /* some sane fallback */ }","highlight_start":1,"highlight_end":1},{"text":"        //     }","highlight_start":1,"highlight_end":1},{"text":"        //","highlight_start":1,"highlight_end":1},{"text":"        // This way we fail your tests but don't break your library when adding","highlight_start":1,"highlight_end":1},{"text":"        // a variant. You will be notified by a test failure when a variant is","highlight_start":1,"highlight_end":1},{"text":"        // added, so that you can add code to handle it, but your library will","highlight_start":1,"highlight_end":1},{"text":"        // continue to compile and work for downstream users in the interim.","highlight_start":1,"highlight_end":1},{"text":"        #[cfg(syn_no_non_exhaustive)]","highlight_start":1,"highlight_end":1},{"text":"        #[doc(hidden)]","highlight_start":1,"highlight_end":1},{"text":"        __NonExhaustive,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_enum_of_structs!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":1374,"byte_end":1406,"line_start":59,"line_end":59,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"macro_rules! ast_enum_of_structs {","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"ast_enum!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":929,"byte_end":950,"line_start":38,"line_end":38,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! ast_enum {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:41:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m41\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                pat,\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `syn::Pat`, found `syn::pat::Pat`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::pat::Pat` and `syn::Pat` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::pat::Pat` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/pat.rs:15:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_enum_of_structs! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// A pattern in a local binding, function signature, match expre\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// various other places.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m101\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m102\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::Pat` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/pat.rs:5:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_enum_of_structs! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// A pattern in a local binding, function signature, match expre\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// various other places.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m8\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m98\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `ast_enum_of_structs` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"a value of type `Vec<syn::Attribute>` cannot be built from an iterator over elements of type `syn::attr::Attribute`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":965,"byte_end":972,"line_start":40,"line_end":40,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"                    .collect(),","highlight_start":22,"highlight_end":29}],"label":"value of type `Vec<syn::Attribute>` cannot be built from `std::iter::Iterator<Item=syn::attr::Attribute>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `FromIterator<syn::attr::Attribute>` is not implemented for `Vec<syn::Attribute>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the trait `FromIterator<syn::Attribute>` is implemented for `Vec<syn::Attribute>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"for that trait implementation, expected `syn::Attribute`, found `syn::attr::Attribute`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the method call chain might not have had the expected associated types","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":793,"byte_end":794,"line_start":35,"line_end":35,"column_start":24,"column_end":25,"is_primary":false,"text":[{"text":"                attrs: v","highlight_start":24,"highlight_end":25}],"label":"this expression has type `VariantBinder<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":935,"byte_end":943,"line_start":39,"line_end":39,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"                    .cloned()","highlight_start":22,"highlight_end":30}],"label":"`Iterator::Item` changed to `Attribute` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":873,"byte_end":913,"line_start":38,"line_end":38,"column_start":22,"column_end":62,"is_primary":false,"text":[{"text":"                    .filter(|attr| is_attr_name(attr, \"cfg\"))","highlight_start":22,"highlight_end":62}],"label":"`Iterator::Item` remains `&Attribute` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":845,"byte_end":851,"line_start":37,"line_end":37,"column_start":22,"column_end":28,"is_primary":false,"text":[{"text":"                    .iter()","highlight_start":22,"highlight_end":28}],"label":"`Iterator::Item` is `&Attribute` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `collect`","code":null,"level":"note","spans":[{"file_name":"/rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/iter/traits/iterator.rs","byte_start":66808,"byte_end":66889,"line_start":1996,"line_end":1998,"column_start":5,"column_end":21,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: a value of type `Vec<syn::Attribute>` cannot be built from an iterator over elements of type `syn::attr::Attribute`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:40:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .collect(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mvalue of type `Vec<syn::Attribute>` cannot be built from `std::iter::Iterator<Item=syn::attr::Attribute>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `FromIterator<syn::attr::Attribute>` is not implemented for `Vec<syn::Attribute>`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `FromIterator<syn::Attribute>` \u001b[0m\u001b[0m\u001b[1m\u001b[35mis\u001b[0m\u001b[0m implemented for `\u001b[0m\u001b[0m\u001b[1m\u001b[35mVec<syn::Attribute>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: for that trait implementation, expected `syn::Attribute`, found `syn::attr::Attribute`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the method call chain might not have had the expected associated types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:39:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                attrs: v\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis expression has type `VariantBinder<'_>`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m36\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .attrs()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m37\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .iter()\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`Iterator::Item` is `&Attribute` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m38\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .filter(|attr| is_attr_name(attr, \"cfg\"))\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------------------------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`Iterator::Item` remains `&Attribute` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m39\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                    .cloned()\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m`Iterator::Item` changed to `Attribute` here\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `collect`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/iter/traits/iterator.rs:1996:5\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1059,"byte_end":1069,"line_start":43,"line_end":43,"column_start":34,"column_end":44,"is_primary":true,"text":[{"text":"                fat_arrow_token: def_site(),","highlight_start":34,"highlight_end":44}],"label":"expected `FatArrow`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:43:34\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m43\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                fat_arrow_token: def_site(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `FatArrow`, found `Span`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1099,"byte_end":1109,"line_start":44,"line_end":44,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"                comma: Some(def_site()),","highlight_start":29,"highlight_end":39}],"label":"expected `Comma`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1094,"byte_end":1098,"line_start":44,"line_end":44,"column_start":24,"column_end":28,"is_primary":false,"text":[{"text":"                comma: Some(def_site()),","highlight_start":24,"highlight_end":28}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `proc_macro2::Span` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1099,"byte_end":1109,"line_start":44,"line_end":44,"column_start":29,"column_end":39,"is_primary":false,"text":[{"text":"                comma: Some(def_site()),","highlight_start":29,"highlight_end":39}],"label":"this argument influences the type of `Some`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1094,"byte_end":1110,"line_start":44,"line_end":44,"column_start":24,"column_end":40,"is_primary":true,"text":[{"text":"                comma: Some(def_site()),","highlight_start":24,"highlight_end":40}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/option.rs","byte_start":22706,"byte_end":22710,"line_start":579,"line_end":579,"column_start":5,"column_end":9,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:44:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                comma: Some(def_site()),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Comma`, found `Span`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this enum variant are incorrect\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: the type constructed contains `proc_macro2::Span` due to the type of the argument passed\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:44:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                comma: Some(def_site()),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----------\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis argument influences the type of `Some`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: tuple variant defined here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/rustc/f6e511eec7342f59a25f7c0534f1dbea00d01b14/library/core/src/option.rs:579:5\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1253,"byte_end":1263,"line_start":51,"line_end":51,"column_start":22,"column_end":32,"is_primary":true,"text":[{"text":"        match_token: def_site(),","highlight_start":22,"highlight_end":32}],"label":"expected `Match`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Match`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1253,"byte_end":1253,"line_start":51,"line_end":51,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"        match_token: def_site(),","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"syn::token::Match { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1263,"byte_end":1263,"line_start":51,"line_end":51,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        match_token: def_site(),","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:51:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        match_token: def_site(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Match`, found `Span`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Match`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m51\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        match_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Match { span: \u001b[0m\u001b[0mdef_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1286,"byte_end":1296,"line_start":52,"line_end":52,"column_start":22,"column_end":32,"is_primary":true,"text":[{"text":"        brace_token: def_site(),","highlight_start":22,"highlight_end":32}],"label":"expected `Brace`, found `Span`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try wrapping the expression in `syn::token::Brace`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1286,"byte_end":1286,"line_start":52,"line_end":52,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"        brace_token: def_site(),","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"syn::token::Brace { span: ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1296,"byte_end":1296,"line_start":52,"line_end":52,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"        brace_token: def_site(),","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":" }","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:52:22\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        brace_token: def_site(),\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `Brace`, found `Span`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try wrapping the expression in `syn::token::Brace`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        brace_token: \u001b[0m\u001b[0m\u001b[38;5;10msyn::token::Brace { span: \u001b[0m\u001b[0mdef_site()\u001b[0m\u001b[0m\u001b[38;5;10m }\u001b[0m\u001b[0m,\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[38;5;10m+++++++++++++++++++++++++\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function takes 0 generic arguments but 1 generic argument was supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1345,"byte_end":1353,"line_start":54,"line_end":54,"column_start":24,"column_end":32,"is_primary":true,"text":[{"text":"            Quote::new(def_site::<Span>())","highlight_start":24,"highlight_end":32}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":283,"byte_end":291,"line_start":18,"line_end":18,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn def_site() -> Span {","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1353,"byte_end":1361,"line_start":54,"line_end":54,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"            Quote::new(def_site::<Span>())","highlight_start":32,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: function takes 0 generic arguments but 1 generic argument was supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:54:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m54\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Quote::new(def_site::<Span>())\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generics\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 generic arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here, with 0 generic parameters\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:18:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn def_site() -> Span {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function takes 0 generic arguments but 1 generic argument was supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1501,"byte_end":1509,"line_start":61,"line_end":61,"column_start":16,"column_end":24,"is_primary":true,"text":[{"text":"    Quote::new(def_site::<Span>())","highlight_start":16,"highlight_end":24}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":283,"byte_end":291,"line_start":18,"line_end":18,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn def_site() -> Span {","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1509,"byte_end":1517,"line_start":61,"line_end":61,"column_start":24,"column_end":32,"is_primary":true,"text":[{"text":"    Quote::new(def_site::<Span>())","highlight_start":24,"highlight_end":32}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: function takes 0 generic arguments but 1 generic argument was supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:61:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Quote::new(def_site::<Span>())\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generics\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 generic arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here, with 0 generic parameters\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:18:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn def_site() -> Span {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `with_generics` found for struct `syn::ItemImpl` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1490,"byte_end":1932,"line_start":61,"line_end":77,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    Quote::new(def_site::<Span>())","highlight_start":5,"highlight_end":35},{"text":"        .quote_with(smart_quote!(","highlight_start":1,"highlight_end":34},{"text":"            Vars {","highlight_start":1,"highlight_end":19},{"text":"                Type: &input.ident,","highlight_start":1,"highlight_end":36},{"text":"                body,","highlight_start":1,"highlight_end":22},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                impl swc_common::Spanned for Type {","highlight_start":1,"highlight_end":52},{"text":"                    #[inline]","highlight_start":1,"highlight_end":30},{"text":"                    fn span(&self) -> swc_common::Span {","highlight_start":1,"highlight_end":57},{"text":"                        body","highlight_start":1,"highlight_end":29},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        ))","highlight_start":1,"highlight_end":11},{"text":"        .parse::<ItemImpl>()","highlight_start":1,"highlight_end":29},{"text":"        .with_generics(input.generics)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":1932,"byte_end":1945,"line_start":77,"line_end":77,"column_start":10,"column_end":23,"is_primary":true,"text":[{"text":"        .with_generics(input.generics)","highlight_start":10,"highlight_end":23}],"label":"method not found in `ItemImpl`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m: no method named `with_generics` found for struct `syn::ItemImpl` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:77:10\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m61\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m    Quote::new(def_site::<Span>())\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m62\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .quote_with(smart_quote!(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m63\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Vars {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m64\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Type: &input.ident,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m76\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .parse::<ItemImpl>()\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m77\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .with_generics(input.generics)\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `ItemImpl`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_________|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":2548,"byte_end":2567,"line_start":97,"line_end":97,"column_start":16,"column_end":35,"is_primary":true,"text":[{"text":"        if let Fields::Unnamed(..) = *v.data() {","highlight_start":16,"highlight_end":35}],"label":"expected `syn::data::Fields`, found `syn::Fields`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":2570,"byte_end":2579,"line_start":97,"line_end":97,"column_start":38,"column_end":47,"is_primary":false,"text":[{"text":"        if let Fields::Unnamed(..) = *v.data() {","highlight_start":38,"highlight_end":47}],"label":"this expression has type `syn::data::Fields`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::Fields` and `syn::data::Fields` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::Fields` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":1327,"byte_end":1362,"line_start":55,"line_end":55,"column_start":9,"column_end":44,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_enum!($($t)*));","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":1543,"byte_end":1594,"line_start":65,"line_end":65,"column_start":9,"column_end":60,"is_primary":false,"text":[{"text":"        ast_enum!($(#[$enum_attr])* $pub $enum $name $body);","highlight_start":9,"highlight_end":60}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/data.rs","byte_start":628,"byte_end":1384,"line_start":25,"line_end":48,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_enum_of_structs! {","highlight_start":1,"highlight_end":1},{"text":"    /// Data stored within an enum variant or struct.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`","highlight_start":1,"highlight_end":1},{"text":"    /// feature.*","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax tree enum","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type is a [syntax tree enum].","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [syntax tree enum]: Expr#syntax-tree-enums","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":1},{"text":"    pub enum Fields {","highlight_start":1,"highlight_end":1},{"text":"        /// Named fields of a struct or struct variant such as `Point { x: f64,","highlight_start":1,"highlight_end":1},{"text":"        /// y: f64 }`.","highlight_start":1,"highlight_end":1},{"text":"        Named(FieldsNamed),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.","highlight_start":1,"highlight_end":1},{"text":"        Unnamed(FieldsUnnamed),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Unit struct or unit variant such as `None`.","highlight_start":1,"highlight_end":1},{"text":"        Unit,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_enum_of_structs!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":1374,"byte_end":1406,"line_start":59,"line_end":59,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"macro_rules! ast_enum_of_structs {","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"ast_enum!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":929,"byte_end":950,"line_start":38,"line_end":38,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! ast_enum {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`syn::data::Fields` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1631,"byte_end":1653,"line_start":61,"line_end":61,"column_start":27,"column_end":49,"is_primary":true,"text":[{"text":"        $(#[$enum_attr])* $pub $enum $name $body","highlight_start":27,"highlight_end":49}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/data.rs","byte_start":651,"byte_end":1308,"line_start":26,"line_end":46,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_enum_of_structs! {","highlight_start":1,"highlight_end":1},{"text":"    /// Data stored within an enum variant or struct.","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// # Syntax tree enum","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// This type is a [syntax tree enum].","highlight_start":1,"highlight_end":1},{"text":"    ///","highlight_start":1,"highlight_end":1},{"text":"    /// [syntax tree enum]: crate::expr::Expr#syntax-tree-enums","highlight_start":1,"highlight_end":1},{"text":"    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":1},{"text":"    pub enum Fields {","highlight_start":1,"highlight_end":1},{"text":"        /// Named fields of a struct or struct variant such as `Point { x: f64,","highlight_start":1,"highlight_end":1},{"text":"        /// y: f64 }`.","highlight_start":1,"highlight_end":1},{"text":"        Named(FieldsNamed),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.","highlight_start":1,"highlight_end":1},{"text":"        Unnamed(FieldsUnnamed),","highlight_start":1,"highlight_end":1},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Unit struct or unit variant such as `None`.","highlight_start":1,"highlight_end":1},{"text":"        Unit,","highlight_start":1,"highlight_end":1},{"text":"    }","highlight_start":1,"highlight_end":1},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_enum_of_structs!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1383,"byte_end":1415,"line_start":53,"line_end":53,"column_start":1,"column_end":33,"is_primary":false,"text":[{"text":"macro_rules! ast_enum_of_structs {","highlight_start":1,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:97:16\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m97\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if let Fields::Unnamed(..) = *v.data() {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis expression has type `syn::data::Fields`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `syn::data::Fields`, found `syn::Fields`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::Fields` and `syn::data::Fields` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::Fields` is defined in crate `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/data.rs:25:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m25\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_enum_of_structs! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Data stored within an enum variant or struct.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// *This type is available only if Syn is built with the `\"derive\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m47\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m48\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::data::Fields` is defined in crate `syn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/data.rs:26:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m26\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_enum_of_structs! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m27\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Data stored within an enum variant or struct.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m28\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m29\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// # Syntax tree enum\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m45\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `strip_attrs_pub` which comes from the expansion of the macro `ast_enum_of_structs` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":2798,"byte_end":2814,"line_start":106,"line_end":106,"column_start":39,"column_end":55,"is_primary":true,"text":[{"text":"        .find(|b| has_empty_span_attr(&b.field().attrs))","highlight_start":39,"highlight_end":55}],"label":"expected `&[Attribute]`, found `&Vec<Attribute>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":2778,"byte_end":2797,"line_start":106,"line_end":106,"column_start":19,"column_end":38,"is_primary":false,"text":[{"text":"        .find(|b| has_empty_span_attr(&b.field().attrs))","highlight_start":19,"highlight_end":38}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected reference `&[syn::Attribute]`\n   found reference `&Vec<syn::attr::Attribute>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":4732,"byte_end":4751,"line_start":168,"line_end":168,"column_start":24,"column_end":43,"is_primary":false,"text":[{"text":"fn has_empty_span_attr(attrs: &[Attribute]) -> bool {","highlight_start":24,"highlight_end":43}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":4712,"byte_end":4731,"line_start":168,"line_end":168,"column_start":4,"column_end":23,"is_primary":true,"text":[{"text":"fn has_empty_span_attr(attrs: &[Attribute]) -> bool {","highlight_start":4,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:106:39\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m106\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .find(|b| has_empty_span_attr(&b.field().attrs))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `&[Attribute]`, found `&Vec<Attribute>`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected reference `&\u001b[0m\u001b[0m\u001b[1m\u001b[35m[syn::Attribute]\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m               found reference `&\u001b[0m\u001b[0m\u001b[1m\u001b[35mVec<syn::attr::Attribute>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:168:4\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m168\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn has_empty_span_attr(attrs: &[Attribute]) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":3870,"byte_end":3879,"line_start":144,"line_end":144,"column_start":42,"column_end":51,"is_primary":true,"text":[{"text":"        .map(|b| (b, MyField::from_field(b.field()).unwrap()))","highlight_start":42,"highlight_end":51}],"label":"expected `syn::Field`, found `syn::data::Field`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":3850,"byte_end":3869,"line_start":144,"line_end":144,"column_start":22,"column_end":41,"is_primary":false,"text":[{"text":"        .map(|b| (b, MyField::from_field(b.field()).unwrap()))","highlight_start":22,"highlight_end":41}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::data::Field` and `syn::Field` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::data::Field` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1028,"byte_end":1052,"line_start":36,"line_end":36,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        $(#[$attr])* $pub $struct $name $body","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/data.rs","byte_start":5798,"byte_end":6276,"line_start":181,"line_end":200,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":14},{"text":"    /// A field of a struct or enum variant.","highlight_start":1,"highlight_end":45},{"text":"    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":77},{"text":"    pub struct Field {","highlight_start":1,"highlight_end":23},{"text":"        pub attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub vis: Visibility,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub mutability: FieldMutability,","highlight_start":1,"highlight_end":41},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Name of the field, if any.","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Fields of tuple structs have no names.","highlight_start":1,"highlight_end":51},{"text":"        pub ident: Option<Ident>,","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub colon_token: Option<Token![:]>,","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub ty: Type,","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`syn::Field` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":880,"byte_end":917,"line_start":34,"line_end":34,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_struct!($($t)*));","highlight_start":9,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/data.rs","byte_start":4433,"byte_end":5093,"line_start":148,"line_end":171,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":14},{"text":"    /// A field of a struct or enum variant.","highlight_start":1,"highlight_end":45},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`","highlight_start":1,"highlight_end":85},{"text":"    /// feature.*","highlight_start":1,"highlight_end":18},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":78},{"text":"    pub struct Field {","highlight_start":1,"highlight_end":23},{"text":"        /// Attributes tagged on the field.","highlight_start":1,"highlight_end":44},{"text":"        pub attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":35},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Visibility of the field.","highlight_start":1,"highlight_end":37},{"text":"        pub vis: Visibility,","highlight_start":1,"highlight_end":29},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Name of the field, if any.","highlight_start":1,"highlight_end":39},{"text":"        ///","highlight_start":1,"highlight_end":12},{"text":"        /// Fields of tuple structs have no names.","highlight_start":1,"highlight_end":51},{"text":"        pub ident: Option<Ident>,","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        pub colon_token: Option<Token![:]>,","highlight_start":1,"highlight_end":44},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        /// Type of the field.","highlight_start":1,"highlight_end":31},{"text":"        pub ty: Type,","highlight_start":1,"highlight_end":22},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/darling_core-0.10.2/src/from_field.rs","byte_start":149,"byte_end":159,"line_start":7,"line_end":7,"column_start":8,"column_end":18,"is_primary":true,"text":[{"text":"    fn from_field(field: &Field) -> Result<Self>;","highlight_start":8,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:144:42\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m144\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        .map(|b| (b, MyField::from_field(b.field()).unwrap()))\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `syn::Field`, found `syn::data::Field`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::data::Field` and `syn::Field` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::data::Field` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/data.rs:181:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m181\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m182\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// A field of a struct or enum variant.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m183\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"deriv\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m184\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    pub struct Field {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m199\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m200\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::Field` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/data.rs:148:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m148\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m149\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// A field of a struct or enum variant.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m150\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m151\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// *This type is available only if Syn is built with the `\"deriv\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m171\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: associated function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/darling_core-0.10.2/src/from_field.rs:7:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn from_field(field: &Field) -> Result<Self>;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `ast_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function takes 0 generic arguments but 1 generic argument was supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":4278,"byte_end":4286,"line_start":155,"line_end":155,"column_start":28,"column_end":36,"is_primary":true,"text":[{"text":"                Quote::new(def_site::<Span>())","highlight_start":28,"highlight_end":36}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":283,"byte_end":291,"line_start":18,"line_end":18,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn def_site() -> Span {","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":4286,"byte_end":4294,"line_start":155,"line_end":155,"column_start":36,"column_end":44,"is_primary":true,"text":[{"text":"                Quote::new(def_site::<Span>())","highlight_start":36,"highlight_end":44}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: function takes 0 generic arguments but 1 generic argument was supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:155:28\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m                Quote::new(def_site::<Span>())\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generics\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 generic arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here, with 0 generic parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:18:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn def_site() -> Span {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function takes 0 generic arguments but 1 generic argument was supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":2202,"byte_end":2210,"line_start":84,"line_end":84,"column_start":24,"column_end":32,"is_primary":true,"text":[{"text":"            Quote::new(def_site::<Span>())","highlight_start":24,"highlight_end":32}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":283,"byte_end":291,"line_start":18,"line_end":18,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn def_site() -> Span {","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":2210,"byte_end":2218,"line_start":84,"line_end":84,"column_start":32,"column_end":40,"is_primary":true,"text":[{"text":"            Quote::new(def_site::<Span>())","highlight_start":32,"highlight_end":40}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: function takes 0 generic arguments but 1 generic argument was supplied\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:84:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            Quote::new(def_site::<Span>())\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generics\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 generic arguments\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here, with 0 generic parameters\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:18:8\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn def_site() -> Span {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":4818,"byte_end":4822,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        if !is_attr_name(attr, \"span\") {","highlight_start":26,"highlight_end":30}],"label":"expected `syn::attr::Attribute`, found `syn::Attribute`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs","byte_start":4805,"byte_end":4817,"line_start":170,"line_end":170,"column_start":13,"column_end":25,"is_primary":false,"text":[{"text":"        if !is_attr_name(attr, \"span\") {","highlight_start":13,"highlight_end":25}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`syn::Attribute` and `syn::attr::Attribute` have similar names, but are actually distinct types","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"`syn::Attribute` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4365,"byte_end":4369,"line_start":170,"line_end":170,"column_start":26,"column_end":30,"is_primary":true,"text":[{"text":"        $mac!([$(#[$m])* $pub] $($t)*);","highlight_start":26,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":880,"byte_end":917,"line_start":34,"line_end":34,"column_start":9,"column_end":46,"is_primary":false,"text":[{"text":"        strip_attrs_pub!(ast_struct!($($t)*));","highlight_start":9,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/attr.rs","byte_start":266,"byte_end":5692,"line_start":12,"line_end":156,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":14},{"text":"    /// An attribute like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":50},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// *This type is available only if Syn is built with the `\"derive\"` or `\"full\"`","highlight_start":1,"highlight_end":85},{"text":"    /// feature.*","highlight_start":1,"highlight_end":18},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":80},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":46},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":79},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":55},{"text":"    /// - Outer doc comments like `/// # Example`.","highlight_start":1,"highlight_end":51},{"text":"    /// - Inner doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":62},{"text":"    /// - Outer block comments `/** # Example */`.","highlight_start":1,"highlight_end":51},{"text":"    /// - Inner block comments `/*! Please file an issue */`.","highlight_start":1,"highlight_end":62},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":81},{"text":"    /// is outer or inner. Doc comments and block comments are promoted to","highlight_start":1,"highlight_end":75},{"text":"    /// attributes, as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":77},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `path` field gives the possibly colon-delimited path against which","highlight_start":1,"highlight_end":79},{"text":"    /// the attribute is resolved. It is equal to `\"doc\"` for desugared doc","highlight_start":1,"highlight_end":76},{"text":"    /// comments. The `tokens` field contains the rest of the attribute body as","highlight_start":1,"highlight_end":80},{"text":"    /// tokens.","highlight_start":1,"highlight_end":16},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// #[derive(Copy)]      #[crate::precondition x < 5]","highlight_start":1,"highlight_end":58},{"text":"    ///   ^^^^^^~~~~~~         ^^^^^^^^^^^^^^^^^^^ ~~~~~","highlight_start":1,"highlight_end":57},{"text":"    ///   path  tokens                 path        tokens","highlight_start":1,"highlight_end":58},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":76},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":63},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":67},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":78},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Parse`]: parse::Parse","highlight_start":1,"highlight_end":32},{"text":"    /// [`ParseStream::parse`]: parse::ParseBuffer::parse","highlight_start":1,"highlight_end":58},{"text":"    /// [`ParseStream::call`]: parse::ParseBuffer::call","highlight_start":1,"highlight_end":56},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":52},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":49},{"text":"    /// //","highlight_start":1,"highlight_end":11},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":34},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":25},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":28},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":35},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":42},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":25},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":35},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":36},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":59},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":32},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":64},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":50},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":42},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":48},{"text":"    ///         })","highlight_start":1,"highlight_end":19},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":76},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":80},{"text":"    /// attribute are held in an arbitrary `tokens: TokenStream`. Macros are","highlight_start":1,"highlight_end":77},{"text":"    /// expected to check the `path` of the attribute, decide whether they","highlight_start":1,"highlight_end":75},{"text":"    /// recognize it, and then parse the remaining tokens according to whatever","highlight_start":1,"highlight_end":80},{"text":"    /// grammar they wish to require for that kind of attribute.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// If the attribute you are parsing is expected to conform to the","highlight_start":1,"highlight_end":71},{"text":"    /// conventional structured form of attribute, use [`parse_meta()`] to","highlight_start":1,"highlight_end":75},{"text":"    /// obtain that structured representation. If the attribute follows some","highlight_start":1,"highlight_end":77},{"text":"    /// other grammar of its own, use [`parse_args()`] to parse that into the","highlight_start":1,"highlight_end":78},{"text":"    /// expected data structure.","highlight_start":1,"highlight_end":33},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`parse_meta()`]: Attribute::parse_meta","highlight_start":1,"highlight_end":48},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":23},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":77},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":81},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":43},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":42},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":41},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":34},{"text":"    ///     /**","highlight_start":1,"highlight_end":16},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      */","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":53},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":48},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":50},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":23},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      \"]","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":63},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":56},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg_attr(doc_cfg, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":78},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":27},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":36},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":30},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":43},{"text":"        pub path: Path,","highlight_start":1,"highlight_end":24},{"text":"        pub tokens: TokenStream,","highlight_start":1,"highlight_end":33},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"strip_attrs_pub!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/macros.rs","byte_start":4206,"byte_end":4234,"line_start":166,"line_end":166,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! strip_attrs_pub {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"`syn::attr::Attribute` is defined in crate `syn`","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":1028,"byte_end":1052,"line_start":36,"line_end":36,"column_start":22,"column_end":46,"is_primary":true,"text":[{"text":"        $(#[$attr])* $pub $struct $name $body","highlight_start":22,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/attr.rs","byte_start":469,"byte_end":6261,"line_start":19,"line_end":179,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"ast_struct! {","highlight_start":1,"highlight_end":14},{"text":"    /// An attribute, like `#[repr(transparent)]`.","highlight_start":1,"highlight_end":51},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Syntax","highlight_start":1,"highlight_end":17},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Rust has six types of attributes.","highlight_start":1,"highlight_end":42},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer attributes like `#[repr(transparent)]`. These appear outside or","highlight_start":1,"highlight_end":80},{"text":"    ///   in front of the item they describe.","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Inner attributes like `#![feature(proc_macro)]`. These appear inside","highlight_start":1,"highlight_end":79},{"text":"    ///   of the item they describe, usually a module.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer one-line doc comments like `/// Example`.","highlight_start":1,"highlight_end":58},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Inner one-line doc comments like `//! Please file an issue`.","highlight_start":1,"highlight_end":71},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Outer documentation blocks `/** Example */`.","highlight_start":1,"highlight_end":55},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Inner documentation blocks `/*! Please file an issue */`.","highlight_start":1,"highlight_end":68},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The `style` field of type `AttrStyle` distinguishes whether an attribute","highlight_start":1,"highlight_end":81},{"text":"    /// is outer or inner.","highlight_start":1,"highlight_end":27},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// Every attribute has a `path` that indicates the intended interpretation","highlight_start":1,"highlight_end":80},{"text":"    /// of the rest of the attribute's contents. The path and the optional","highlight_start":1,"highlight_end":75},{"text":"    /// additional contents are represented together in the `meta` field of the","highlight_start":1,"highlight_end":80},{"text":"    /// attribute in three possible varieties:","highlight_start":1,"highlight_end":47},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Meta::Path &mdash; attributes whose information content conveys just a","highlight_start":1,"highlight_end":81},{"text":"    ///   path, for example the `#[test]` attribute.","highlight_start":1,"highlight_end":53},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Meta::List &mdash; attributes that carry arbitrary tokens after the","highlight_start":1,"highlight_end":78},{"text":"    ///   path, surrounded by a delimiter (parenthesis, bracket, or brace). For","highlight_start":1,"highlight_end":80},{"text":"    ///   example `#[derive(Copy)]` or `#[precondition(x < 5)]`.","highlight_start":1,"highlight_end":65},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// - Meta::NameValue &mdash; attributes with an `=` sign after the path,","highlight_start":1,"highlight_end":78},{"text":"    ///   followed by a Rust expression. For example `#[path =","highlight_start":1,"highlight_end":63},{"text":"    ///   \"sys/windows.rs\"]`.","highlight_start":1,"highlight_end":30},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// All doc comments are represented in the NameValue style with a path of","highlight_start":1,"highlight_end":79},{"text":"    /// \"doc\", as this is how they are processed by the compiler and by","highlight_start":1,"highlight_end":72},{"text":"    /// `macro_rules!` macros.","highlight_start":1,"highlight_end":31},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```text","highlight_start":1,"highlight_end":16},{"text":"    /// #[derive(Copy, Clone)]","highlight_start":1,"highlight_end":31},{"text":"    ///   ~~~~~~Path","highlight_start":1,"highlight_end":21},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^Meta::List","highlight_start":1,"highlight_end":40},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// #[path = \"sys/windows.rs\"]","highlight_start":1,"highlight_end":35},{"text":"    ///   ~~~~Path","highlight_start":1,"highlight_end":19},{"text":"    ///   ^^^^^^^^^^^^^^^^^^^^^^^Meta::NameValue","highlight_start":1,"highlight_end":49},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// #[test]","highlight_start":1,"highlight_end":16},{"text":"    ///   ^^^^Meta::Path","highlight_start":1,"highlight_end":25},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <br>","highlight_start":1,"highlight_end":13},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from tokens to Attribute","highlight_start":1,"highlight_end":43},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// This type does not implement the [`Parse`] trait and thus cannot be","highlight_start":1,"highlight_end":76},{"text":"    /// parsed directly by [`ParseStream::parse`]. Instead use","highlight_start":1,"highlight_end":63},{"text":"    /// [`ParseStream::call`] with one of the two parser functions","highlight_start":1,"highlight_end":67},{"text":"    /// [`Attribute::parse_outer`] or [`Attribute::parse_inner`] depending on","highlight_start":1,"highlight_end":78},{"text":"    /// which you intend to parse.","highlight_start":1,"highlight_end":35},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`Parse`]: crate::parse::Parse","highlight_start":1,"highlight_end":39},{"text":"    /// [`ParseStream::parse`]: crate::parse::ParseBuffer::parse","highlight_start":1,"highlight_end":65},{"text":"    /// [`ParseStream::call`]: crate::parse::ParseBuffer::call","highlight_start":1,"highlight_end":63},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// use syn::{Attribute, Ident, Result, Token};","highlight_start":1,"highlight_end":52},{"text":"    /// use syn::parse::{Parse, ParseStream};","highlight_start":1,"highlight_end":46},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// // Parses a unit struct with attributes.","highlight_start":1,"highlight_end":49},{"text":"    /// //","highlight_start":1,"highlight_end":11},{"text":"    /// //     #[path = \"s.tmpl\"]","highlight_start":1,"highlight_end":34},{"text":"    /// //     struct S;","highlight_start":1,"highlight_end":25},{"text":"    /// struct UnitStruct {","highlight_start":1,"highlight_end":28},{"text":"    ///     attrs: Vec<Attribute>,","highlight_start":1,"highlight_end":35},{"text":"    ///     struct_token: Token![struct],","highlight_start":1,"highlight_end":42},{"text":"    ///     name: Ident,","highlight_start":1,"highlight_end":25},{"text":"    ///     semi_token: Token![;],","highlight_start":1,"highlight_end":35},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// impl Parse for UnitStruct {","highlight_start":1,"highlight_end":36},{"text":"    ///     fn parse(input: ParseStream) -> Result<Self> {","highlight_start":1,"highlight_end":59},{"text":"    ///         Ok(UnitStruct {","highlight_start":1,"highlight_end":32},{"text":"    ///             attrs: input.call(Attribute::parse_outer)?,","highlight_start":1,"highlight_end":64},{"text":"    ///             struct_token: input.parse()?,","highlight_start":1,"highlight_end":50},{"text":"    ///             name: input.parse()?,","highlight_start":1,"highlight_end":42},{"text":"    ///             semi_token: input.parse()?,","highlight_start":1,"highlight_end":48},{"text":"    ///         })","highlight_start":1,"highlight_end":19},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// }","highlight_start":1,"highlight_end":10},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Parsing from Attribute to structured arguments","highlight_start":1,"highlight_end":57},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The grammar of attributes in Rust is very flexible, which makes the","highlight_start":1,"highlight_end":76},{"text":"    /// syntax tree not that useful on its own. In particular, arguments of the","highlight_start":1,"highlight_end":80},{"text":"    /// `Meta::List` variety of attribute are held in an arbitrary `tokens:","highlight_start":1,"highlight_end":76},{"text":"    /// TokenStream`. Macros are expected to check the `path` of the attribute,","highlight_start":1,"highlight_end":80},{"text":"    /// decide whether they recognize it, and then parse the remaining tokens","highlight_start":1,"highlight_end":78},{"text":"    /// according to whatever grammar they wish to require for that kind of","highlight_start":1,"highlight_end":76},{"text":"    /// attribute. Use [`parse_args()`] to parse those tokens into the expected","highlight_start":1,"highlight_end":80},{"text":"    /// data structure.","highlight_start":1,"highlight_end":24},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// [`parse_args()`]: Attribute::parse_args","highlight_start":1,"highlight_end":48},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// <p><br></p>","highlight_start":1,"highlight_end":20},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// # Doc comments","highlight_start":1,"highlight_end":23},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// The compiler transforms doc comments, such as `/// comment` and `/*!","highlight_start":1,"highlight_end":77},{"text":"    /// comment */`, into attributes before macros are expanded. Each comment is","highlight_start":1,"highlight_end":81},{"text":"    /// expanded into an attribute of the form `#[doc = r\"comment\"]`.","highlight_start":1,"highlight_end":70},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// As an example, the following `mod` items are expanded identically:","highlight_start":1,"highlight_end":75},{"text":"    ///","highlight_start":1,"highlight_end":8},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    /// # use syn::{ItemMod, parse_quote};","highlight_start":1,"highlight_end":43},{"text":"    /// let doc: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":42},{"text":"    ///     /// Single line doc comments","highlight_start":1,"highlight_end":41},{"text":"    ///     /// We write so many!","highlight_start":1,"highlight_end":34},{"text":"    ///     /**","highlight_start":1,"highlight_end":16},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      */","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         //! Of course, they can be inner too","highlight_start":1,"highlight_end":53},{"text":"    ///         /*! And fit in a single line */","highlight_start":1,"highlight_end":48},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// let attr: ItemMod = parse_quote! {","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\" Single line doc comments\"]","highlight_start":1,"highlight_end":50},{"text":"    ///     #[doc = r\" We write so many!\"]","highlight_start":1,"highlight_end":43},{"text":"    ///     #[doc = r\"","highlight_start":1,"highlight_end":23},{"text":"    ///      * Multi-line comments...","highlight_start":1,"highlight_end":38},{"text":"    ///      * May span many lines","highlight_start":1,"highlight_end":35},{"text":"    ///      \"]","highlight_start":1,"highlight_end":16},{"text":"    ///     mod example {","highlight_start":1,"highlight_end":26},{"text":"    ///         #![doc = r\" Of course, they can be inner too\"]","highlight_start":1,"highlight_end":63},{"text":"    ///         #![doc = r\" And fit in a single line \"]","highlight_start":1,"highlight_end":56},{"text":"    ///     }","highlight_start":1,"highlight_end":14},{"text":"    /// };","highlight_start":1,"highlight_end":11},{"text":"    /// assert_eq!(doc, attr);","highlight_start":1,"highlight_end":31},{"text":"    /// ```","highlight_start":1,"highlight_end":12},{"text":"    #[cfg_attr(docsrs, doc(cfg(any(feature = \"full\", feature = \"derive\"))))]","highlight_start":1,"highlight_end":77},{"text":"    pub struct Attribute {","highlight_start":1,"highlight_end":27},{"text":"        pub pound_token: Token![#],","highlight_start":1,"highlight_end":36},{"text":"        pub style: AttrStyle,","highlight_start":1,"highlight_end":30},{"text":"        pub bracket_token: token::Bracket,","highlight_start":1,"highlight_end":43},{"text":"        pub meta: Meta,","highlight_start":1,"highlight_end":24},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"ast_struct!","def_site_span":{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/macros.rs","byte_start":112,"byte_end":135,"line_start":5,"line_end":5,"column_start":1,"column_end":24,"is_primary":false,"text":[{"text":"macro_rules! ast_struct {","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null},{"message":"perhaps two different versions of crate `syn` are being used?","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":728,"byte_end":740,"line_start":35,"line_end":35,"column_start":8,"column_end":20,"is_primary":true,"text":[{"text":"pub fn is_attr_name(attr: &Attribute, name: &str) -> bool {","highlight_start":8,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/spanned.rs:170:26\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m170\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        if !is_attr_name(attr, \"span\") {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `syn::attr::Attribute`, found `syn::Attribute`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `syn::Attribute` and `syn::attr::Attribute` have similar names, but are actually distinct types\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::Attribute` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-1.0.109/src/attr.rs:12:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// *This type is available only if Syn is built with the `\"deriv\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m155\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m156\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: `syn::attr::Attribute` is defined in crate `syn`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/syn-2.0.106/src/attr.rs:19:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mast_struct! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// An attribute, like `#[repr(transparent)]`.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    ///\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m22\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// <br>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m178\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m179\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: perhaps two different versions of crate `syn` are being used?\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:35:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m35\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn is_attr_name(attr: &Attribute, name: &str) -> bool {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `strip_attrs_pub` which comes from the expansion of the macro `ast_struct` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":4297,"byte_end":4301,"line_start":142,"line_end":142,"column_start":24,"column_end":28,"is_primary":true,"text":[{"text":"    print(\"ast_serde\", item)","highlight_start":24,"highlight_end":28}],"label":"expected `TokenStream`, found `Quote`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":4278,"byte_end":4283,"line_start":142,"line_end":142,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    print(\"ast_serde\", item)","highlight_start":5,"highlight_end":10}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":402,"byte_end":407,"line_start":23,"line_end":23,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"pub fn print(attr: &'static str, tokens: proc_macro2::TokenStream) -> proc_macro::TokenStream {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `Quote` into `TokenStream2`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":4301,"byte_end":4301,"line_start":142,"line_end":142,"column_start":28,"column_end":28,"is_primary":true,"text":[{"text":"    print(\"ast_serde\", item)","highlight_start":28,"highlight_end":28}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs:142:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    print(\"ast_serde\", item)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `TokenStream`, found `Quote`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:23:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn print(attr: &'static str, tokens: proc_macro2::TokenStream) -> p\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: call `Into::into` on this expression to convert `Quote` into `TokenStream2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m142\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    print(\"ast_serde\", item\u001b[0m\u001b[0m\u001b[38;5;10m.into()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9135,"byte_end":9139,"line_start":285,"line_end":285,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"    print(\"ast_node\", item)","highlight_start":23,"highlight_end":27}],"label":"expected `TokenStream`, found `Quote`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9117,"byte_end":9122,"line_start":285,"line_end":285,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    print(\"ast_node\", item)","highlight_start":5,"highlight_end":10}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":402,"byte_end":407,"line_start":23,"line_end":23,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"pub fn print(attr: &'static str, tokens: proc_macro2::TokenStream) -> proc_macro::TokenStream {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `Quote` into `TokenStream2`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9139,"byte_end":9139,"line_start":285,"line_end":285,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"    print(\"ast_node\", item)","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs:285:23\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    print(\"ast_node\", item)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `TokenStream`, found `Quote`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:23:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn print(attr: &'static str, tokens: proc_macro2::TokenStream) -> p\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: call `Into::into` on this expression to convert `Quote` into `TokenStream2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m285\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    print(\"ast_node\", item\u001b[0m\u001b[0m\u001b[38;5;10m.into()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"function takes 0 generic arguments but 1 generic argument was supplied","code":{"code":"E0107","explanation":"An incorrect number of generic arguments was provided.\n\nErroneous code example:\n\n```compile_fail,E0107\nstruct Foo<T> { x: T }\n\nstruct Bar { x: Foo }             // error: wrong number of type arguments:\n                                  //        expected 1, found 0\nstruct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n                                  //        expected 1, found 2\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool>(x);                 // error: wrong number of type arguments:\n                                    //        expected 2, found 1\n    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n                                    //        expected 2, found 3\n    f::<'static>();                 // error: wrong number of lifetime arguments\n                                    //        expected 0, found 1\n}\n```\n\nWhen using/declaring an item with generic arguments, you must provide the exact\nsame number:\n\n```\nstruct Foo<T> { x: T }\n\nstruct Bar<T> { x: Foo<T> }               // ok!\nstruct Baz<S, T> { x: Foo<S>, y: Foo<T> } // ok!\n\nfn foo<T, U>(x: T, y: U) {}\nfn f() {}\n\nfn main() {\n    let x: bool = true;\n    foo::<bool, u32>(x, 12);              // ok!\n    f();                                  // ok!\n}\n```\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9360,"byte_end":9368,"line_start":294,"line_end":294,"column_start":27,"column_end":35,"is_primary":true,"text":[{"text":"    let item = Quote::new(def_site::<Span>()).quote_with(smart_quote!(","highlight_start":27,"highlight_end":35}],"label":"expected 0 generic arguments","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here, with 0 generic parameters","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":283,"byte_end":291,"line_start":18,"line_end":18,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"pub fn def_site() -> Span {","highlight_start":8,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"remove the unnecessary generics","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9368,"byte_end":9376,"line_start":294,"line_end":294,"column_start":35,"column_end":43,"is_primary":true,"text":[{"text":"    let item = Quote::new(def_site::<Span>()).quote_with(smart_quote!(","highlight_start":35,"highlight_end":43}],"label":null,"suggested_replacement":"","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0107]\u001b[0m\u001b[0m\u001b[1m: function takes 0 generic arguments but 1 generic argument was supplied\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs:294:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m294\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let item = Quote::new(def_site::<Span>()).quote_with(smart_quote!(\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove the unnecessary generics\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                           \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected 0 generic arguments\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here, with 0 generic parameters\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:18:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn def_site() -> Span {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9605,"byte_end":9609,"line_start":303,"line_end":303,"column_start":17,"column_end":21,"is_primary":true,"text":[{"text":"    print(name, item)","highlight_start":17,"highlight_end":21}],"label":"expected `TokenStream`, found `Quote`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9593,"byte_end":9598,"line_start":303,"line_end":303,"column_start":5,"column_end":10,"is_primary":false,"text":[{"text":"    print(name, item)","highlight_start":5,"highlight_end":10}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs","byte_start":402,"byte_end":407,"line_start":23,"line_end":23,"column_start":8,"column_end":13,"is_primary":true,"text":[{"text":"pub fn print(attr: &'static str, tokens: proc_macro2::TokenStream) -> proc_macro::TokenStream {","highlight_start":8,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"call `Into::into` on this expression to convert `Quote` into `TokenStream2`","code":null,"level":"help","spans":[{"file_name":"/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs","byte_start":9609,"byte_end":9609,"line_start":303,"line_end":303,"column_start":21,"column_end":21,"is_primary":true,"text":[{"text":"    print(name, item)","highlight_start":21,"highlight_end":21}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/ast_node-0.7.7/src/lib.rs:303:17\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    print(name, item)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-----\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `TokenStream`, found `Quote`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12marguments to this function are incorrect\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function defined here\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/usr/local/cargo/registry/src/index.crates.io-6f17d22bba15001f/swc_macros_common-0.3.14/src/lib.rs:23:8\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m23\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn print(attr: &'static str, tokens: proc_macro2::TokenStream) -> p\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: call `Into::into` on this expression to convert `Quote` into `TokenStream2`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m303\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    print(name, item\u001b[0m\u001b[0m\u001b[38;5;10m.into()\u001b[0m\u001b[0m)\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[38;5;10m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 34 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 34 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0107, E0277, E0308, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0107, E0277, E0308, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0107`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0107`.\u001b[0m\n"}
